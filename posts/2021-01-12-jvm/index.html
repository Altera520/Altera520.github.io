<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>JVM 구조 - Juneee blog</title><meta name=Description content><meta property="og:title" content="JVM 구조"><meta property="og:description" content="JVM 정의 javac를 통해 생성된 Byte Code를 OS에 맞게 해석하여 실행시켜주는 역할을 수행한다. JVM은 크게 봤을 때 5개의 컴포넌트로 나뉜다.
 Class Loader Execution Engine Runtime Date Area JNI Native method library  이 5개의 컴포넌트 중 JNI와 Native method library를 제외한 3가지 컴포넌트에 대해 정리하고자 한다.
 Java Virtual Machine Architecture (이미지 출처: medium."><meta property="og:type" content="article"><meta property="og:url" content="https://altera520.github.io/posts/2021-01-12-jvm/"><meta property="article:published_time" content="2021-01-12T18:47:35+09:00"><meta property="article:modified_time" content="2021-01-12T18:47:35+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM 구조"><meta name=twitter:description content="JVM 정의 javac를 통해 생성된 Byte Code를 OS에 맞게 해석하여 실행시켜주는 역할을 수행한다. JVM은 크게 봤을 때 5개의 컴포넌트로 나뉜다.
 Class Loader Execution Engine Runtime Date Area JNI Native method library  이 5개의 컴포넌트 중 JNI와 Native method library를 제외한 3가지 컴포넌트에 대해 정리하고자 한다.
 Java Virtual Machine Architecture (이미지 출처: medium."><meta name=application-name content="Juneee blog"><meta name=apple-mobile-web-app-title content="Juneee blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://altera520.github.io/posts/2021-01-12-jvm/><link rel=prev href=https://altera520.github.io/posts/2021-01-06-singleton/><link rel=next href=https://altera520.github.io/posts/2021-02-17-java8-features-1st/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"JVM 구조","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/altera520.github.io\/posts\/2021-01-12-jvm\/"},"genre":"posts","keywords":"Java","wordcount":863,"url":"https:\/\/altera520.github.io\/posts\/2021-01-12-jvm\/","datePublished":"2021-01-12T18:47:35+09:00","dateModified":"2021-01-12T18:47:35+09:00","publisher":{"@type":"Organization","name":"altera520"},"author":{"@type":"Person","name":"altera520"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('light'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'light'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><img src=/images/shiba.png class=img-profile alt=main width=35 height=35>
<a href=/ title="Juneee blog">Juneee blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><img src=/images/shiba.png class=img-profile alt=main width=35 height=35>
<a href=/ title="Juneee blog">Juneee blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+=' has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title><i class="fas fa-book"></i>index</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">JVM 구조</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>altera520</a></span>&nbsp;<span class=post-category>included in <a href=/categories/programming/><i class="far fa-folder fa-fw"></i>Programming</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-12>2021-01-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;863 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;5 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span><i class="details-icon fas fa-angle-right"></i>index</span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#jvm-정의>JVM 정의</a></li><li><a href=#jvm-구성-요소>JVM 구성 요소</a><ul><li><a href=#클래스-로더class-loader>클래스 로더(Class Loader)</a></li><li><a href=#런타임-데이터-영역runtime-data-area>런타임 데이터 영역(Runtime Data Area)</a></li><li><a href=#실행-엔진execution-engine>실행 엔진(Execution Engine)</a></li></ul></li><li><a href=#footnote>footnote</a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class=content id=content><h2 id=jvm-정의>JVM 정의</h2><p><strong>javac를 통해 생성된 Byte Code를 OS에 맞게 해석하여 실행시켜주는 역할을 수행한다.</strong><br>JVM은 크게 봤을 때 5개의 컴포넌트로 나뉜다.</p><ul><li>Class Loader</li><li>Execution Engine</li><li>Runtime Date Area</li><li>JNI</li><li>Native method library</li></ul><p>이 5개의 컴포넌트 중 JNI와 Native method library를 제외한 3가지 컴포넌트에 대해 정리하고자 한다.</p><br><figure><a class=lightgallery href=/images/2021-01-12-jvm/jvm-architecture.png title=/images/2021-01-12-jvm/jvm-architecture.png data-thumbnail=/images/2021-01-12-jvm/jvm-architecture.png data-sub-html="<h2>Java Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-01-12-jvm/jvm-architecture.png data-srcset="/images/2021-01-12-jvm/jvm-architecture.png, /images/2021-01-12-jvm/jvm-architecture.png 1.5x, /images/2021-01-12-jvm/jvm-architecture.png 2x" data-sizes=auto alt=/images/2021-01-12-jvm/jvm-architecture.png width=90%></a><figcaption class=image-caption>Java Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce)</figcaption></figure><br><h2 id=jvm-구성-요소>JVM 구성 요소</h2><h3 id=클래스-로더class-loader>클래스 로더(Class Loader)</h3><p>클래스 로더는 JRE의 일부로서 <strong>런타임시 클래스들에 대한 정의를 런타임 데이터 영역에 <a href=/posts/2021-01-23-dynamic-loading rel>동적 로드</a>하는 역할을 수행한다.</strong><br>클래스 로딩시에는 Thread-safe가 보장되고 한 번 로드된 클래스는 언로드 될 수 없다.</p><br><h4 id=3가지-클래스-로더>3가지 클래스 로더</h4><figure><a class=lightgallery href=/images/2021-01-12-jvm/classloader-hierarchy.png title=/images/2021-01-12-jvm/classloader-hierarchy.png data-thumbnail=/images/2021-01-12-jvm/classloader-hierarchy.png data-sub-html="<h2>Class Loader Hierarchy (출처: medium.com/@minfuyang)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-01-12-jvm/classloader-hierarchy.png data-srcset="/images/2021-01-12-jvm/classloader-hierarchy.png, /images/2021-01-12-jvm/classloader-hierarchy.png 1.5x, /images/2021-01-12-jvm/classloader-hierarchy.png 2x" data-sizes=auto alt=/images/2021-01-12-jvm/classloader-hierarchy.png width=85%></a><figcaption class=image-caption>Class Loader Hierarchy (출처: medium.com/@minfuyang)</figcaption></figure><ol><li><strong>Bootstrap class loader</strong><br>네이티브 코드로 구현되어 있으며 3가지 기본 클래스 로더 중에서 최상위 클래스 로더이다.<br>JVM이 실행되면 가장 우선적으로 부트스트랩 로더가 메모리상에 적재되며 이후 자바 클래스들을 로드할 수 있는 <code>java.lang.ClassLoader</code>를 포함하여 최상위 클래스(Object, String, &mldr;)들을 로딩한다.<ul><li>java8 : <code>${JAVA_HOME}/jre/lib/rt.jar</code>내에 있는 모든 JDK 내부 클래스를 로드한다.</li><li>java9 : <code>rt.jar</code>이 제거되고 <code>/lib</code>내에 모듈화되어 포함되었다.</li></ul></li></ol><br><ol start=2><li><strong>Extention class loader</strong><br>기본 자바 API를 제외한 확장클래스들을 로드한다.<ul><li>java8 : <code>URLClassLoader</code>를 상속, <code>jre/lib/ext</code>내의 모든 클래스를 로드</li><li>java9 : <code>URLClassLoader</code>대신 <code>BuiltinClassLoader</code>를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, Platform Class Loader로 명칭 변경</li></ul></li></ol><br><ol start=3><li><strong>Application class loader</strong><br>사용자가 지정한 <code>$CLASSPATH</code>내의 모든 클래스들을 로드한다. 즉, 애플리케이션의 클래스들을 로드한다.<ul><li>java9 : <code>URLClassLoader</code>대신 <code>BuiltinClassLoader</code>를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, System Class Loader로 명칭 변경</li></ul></li></ol><br><ol start=4><li><strong>User-Defined class loader</strong><br>기본 클래스 로더가 아니다.<br>만약 3가지 클래스 로더가 사용하는 classpath외에 위치한 클래스를 로드시키고자 한다면 <code>java.lang.ClassLoader</code> 클래스를 상속하고 <code>findClass</code>메서드를 오버라이드한 커스텀 클래스 로더를 만들면된다.</li></ol><br><h4 id=3가지-원칙>3가지 원칙</h4><p>클래스로더가 지켜야하는 3가지 원칙은 <code>java.lang.ClassLoader</code>의 <code>loadClass</code>메서드에 <a href=http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/ClassLoader.java#l401 target=_blank rel="noopener noreffer">코드</a>로 구현되어 있다.</p><ol><li><p><strong>위임 (Delegation)</strong><br>클래스 로딩이 필요할 때 <strong>하위 클래스 로더에서 상위 클래스 로더 방향으로 클래스 로딩을 위임하는 것</strong>을 말한다.</p><table><thead><tr><th style=text-align:center>step</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:left>Method Area에 클래스가 로드되어 있는지 확인한다. 로드되어 있다면 해당 클래스를 사용한다.</td></tr><tr><td style=text-align:center><span class=md-b>2</span></td><td style=text-align:left>Method Area에 클래스가 로드되어 있지 않다면,<br>애플리케이션 클래스 로더에게 클래스 로드를 요청한다.</td></tr><tr><td style=text-align:center><span class=md-b>3</span></td><td style=text-align:left>애플리케이션 클래스 로더는 확장 클래스로더에게 로딩을 요청한다.</td></tr><tr><td style=text-align:center><span class=md-b>4</span></td><td style=text-align:left>확장 클래스 로더는 부트스트랩 클래스로더에게 로딩을 요청한다.</td></tr><tr><td style=text-align:center><span class=md-g>5</span></td><td style=text-align:left>부트스트랩 클래스 로더는 부트스트랩 classpath에 요청받은 클래스가 있는지 확인한다.<br>요청받은 클래스가 존재하지 않는다면 확장 클래스로더가 요청을 수행하도록 한다.</td></tr><tr><td style=text-align:center><span class=md-g>6</span></td><td style=text-align:left>확장 클래스 로더는 확장 classpath에 요청받은 클래스가 있는지 확인한다.<br>요청받은 클래스가 존재하지 않는다면 애플리케이션 클래스로더가 요청을 수행하도록 한다.</td></tr><tr><td style=text-align:center><span class=md-g>7</span></td><td style=text-align:left>애플리케이션 클래스 로더는 애플리케이션 classpath에 요청받은 클래스가 있는지 확인한다.<br>클래스가 존재하지 않는다면 <code>java.lang.ClassNotFoundException</code>이 발생한다.</td></tr></tbody></table></li><li><p><strong>가시성 제한 (Visibility)</strong><br>하위 클래스 로더는 상위 클래스 로더에 의해 로드된 모든 클래스를 볼 수 있다. 하지만 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 볼 수 없다.</p></li><li><p><strong>유일성 (Uniqueness)</strong><br>상위 클래스 로더가 기존에 로딩해둔 클래스를 하위 클래스 로더가 다시 로딩하지 않도록하여 중복로딩을 방지하고 클래스의 유일성을 보장하기 위한 원칙이다.</p></li></ol><br><h4 id=3단계-작동>3단계 작동</h4><ol><li><p><strong>로딩 (loading)</strong><br>위임 형식에 맞게 기본 클래스 로더들이 동작하여,<br>클래스의 바이트 코드를 가져온 후 Method Area에 로드시킨다.</p></li><li><p><strong>링킹 (linking)</strong></p><table><thead><tr><th style=text-align:center>step</th><th style=text-align:left>name</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:left>검증 (verify)</td><td style=text-align:left>로드한 클래스의 바이트 코드들이 자바 언어 명세와 JVM 명세에 맞게 구성되어있는지 검사한다.</td></tr><tr><td style=text-align:center>2</td><td style=text-align:left>준비 (prepare)</td><td style=text-align:left>클래스가 필요로 하는 메모리를 할당하며 클래스내에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.</td></tr><tr><td style=text-align:center>3</td><td style=text-align:left>분석 (resolve)</td><td style=text-align:left>클래스 상수 풀의 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.<sup><a href=#footnote_1 rel>[1]</a></sup></td></tr></tbody></table></li><li><p><strong>초기화 (initialization)</strong><br>static initializer들을 수행하고 static 필드들을 설정된 값으로 초기화한다.</p></li></ol><br><h3 id=런타임-데이터-영역runtime-data-area>런타임 데이터 영역(Runtime Data Area)</h3><figure><a class=lightgallery href=/images/2021-01-12-jvm/runtime-data-area.png title=/images/2021-01-12-jvm/runtime-data-area.png data-thumbnail=/images/2021-01-12-jvm/runtime-data-area.png data-sub-html="<h2>Runtime Data Area(이미지 출처: javarevisited.blogspot.com)</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-01-12-jvm/runtime-data-area.png data-srcset="/images/2021-01-12-jvm/runtime-data-area.png, /images/2021-01-12-jvm/runtime-data-area.png 1.5x, /images/2021-01-12-jvm/runtime-data-area.png 2x" data-sizes=auto alt=/images/2021-01-12-jvm/runtime-data-area.png width=100%></a><figcaption class=image-caption>Runtime Data Area(이미지 출처: javarevisited.blogspot.com)</figcaption></figure><p><strong>JVM이 Byte Code를 실행시키기 위해 OS로 부터 할당 받은 메모리 공간이다.</strong><br>Runtime Data Area는 5개의 부분으로 나뉜다.</p><table><thead><tr><th style=text-align:left>name</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:left>Method Area</td><td style=text-align:left>모든 스레드가 공유하는 메모리 영역이며 JVM이 시작될 때 생성된다.<br>메서드 영역은 Permanent Area(또는 Permanent Generation)로 불리며 해당 영역의 GC 수행 여부는 JVM 벤더마다 다르다.<br>메서드 영역에는 아래의 데이터들이 위치한다.<ul><li><strong>런타임 상수 풀(Runtime Constant Pool)</strong><sup><a href=#footnote_2 rel>[2]</a></sup><br><p>.class 파일에서 constant_pool 테이블에 해당하는 영역이며 각 클래스와 인터페이스의 상수, 메서드와 필드에 대한 모든 참조를 담고 있는 테이블이다.<br>어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.</p></li><li>FQCN (Fully Qualified Class Name)</li><li>필드와 메서드 정보</li><li>static 변수</li><li>바이트 코드</li></ul></td></tr><tr><td style=text-align:left>Heap</td><td style=text-align:left>동적으로 생성된 인스턴스를 저장하는 구역이며 <a href rel>GC</a>는 해당영역에서 수행된다.<br><ul><li>Young Generation<ul><li>Eden</li><li>S0 (Survivor 0)</li><li>S1 (Survivor 1)</li></ul></li><li>Old Generation<ul><li>Tenured</li><li>Permanent<sup><a href=#footnote_3 rel>[3]</a></sup></li></ul></li></ul></td></tr><tr><td style=text-align:left>JVM Language Stack</td><td style=text-align:left>스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.<br>스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택이며 JVM은 스택에 스택 프레임을 push, pop하는 연산을 수행한다.<br>스택 프레임은 아래와 같은 구조를 가진다.<ul><li>Local Variable Array</li><li>Operand Stack</li><li>Reference Constant Pool</li></ul>예외 발생시 <code>printStackTrace()</code>메서드 호출 시 각 라인들은 하나의 stack frame을 표현한다.</td></tr><tr><td style=text-align:left>Native Method Stack</td><td style=text-align:left>스레드마다 하나씩 존재하며<br>unmanaged language로 작성된 코드를 위한 스택이다.</td></tr><tr><td style=text-align:left>PC Register</td><td style=text-align:left>스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.<br>현재 수행중인 JVM 명령 주소를 가진다.</td></tr></tbody></table><br><h3 id=실행-엔진execution-engine>실행 엔진(Execution Engine)</h3><p><strong>실행 엔진은 런타임 데이터 영역에 클래스 로더를 통해 로드된 바이트코드를 실행하는 역할을 수행한다.</strong></p><p>실행 엔진은 두 가지 방식으로 작동한다.</p><table><thead><tr><th style=text-align:left>name</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:left>인터프리터</td><td style=text-align:left>바이트 코드 명령어를 하나씩 읽어들여 해석하고 실행한다.</td></tr><tr><td style=text-align:left>JIT 컴파일러<sup><a href=#footnote_4 rel>[4]</a></sup></td><td style=text-align:left>인터프리터의 단점<sup><a href=#footnote_5 rel>[5]</a></sup>을 보완하기 위해 도입되었다.<br>인터프리터 방식으로 실행하다가 일정한 기준이 넘어가면 바이트 코드 전체를 컴파일하여 네이티브 코드를 생성하고 이후부터 해당 바이트 코드는 더 이상 인터프리터 방식으로 실행하는 것이 아닌 네이티브 코드를 통해 실행하는 방식을 취한다.</td></tr></tbody></table><br><h2 id=footnote>footnote</h2><p><a name=footnote_1>[1]</a> .class 파일은 실행 시 링크를 할 수 있도록 심볼릭 레퍼런스(Symbolic Reference)만을 가지고 있다. 런타임 시점에 실제 물리적인 주소인 다이렉트 레퍼런스(Direct Reference)로 대체되는 작업인 Dynamic linking이 일어난다.<br><a name=footnote_2>[2]</a> 메서드 영역에 포함되나 JVM에서 핵심적인 동작을 수행하는 부분이기에 <a href=https://docs.oracle.com/javase/specs/jvms/se6/html/ConstantPool.doc.html target=_blank rel="noopener noreffer">JVM 명세</a>에서도 중요하게 기술해두고 있다.<br><a name=footnote_3>[3]</a> Permanent Generation은 메서드 영역이다. 해당 영역의 GC 여부는 JVM 벤더에 따라 다르며
Heap 영역에 위치하지는 않으나 편의상 Heap 영역에 기술해두었다.<br><a name=footnote_4>[4]</a> JIT는 AOT와 반대되는 성향을 가진다.<br><a name=footnote_5>[5]</a> 코드를 줄단위로 해석해여 실행하기에 컴파일 방식보다 상대적으로 실행 속도가 느리다.</p><br><h2 id=references>References</h2><ul><li><a href=https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html#axzz6jon9ev9c target=_blank rel="noopener noreffer">javarevisited.blogspot.com</a></li><li><a href=https://d2.naver.com/helloworld/1230 target=_blank rel="noopener noreffer">Naver D2 - JVM internal</a></li><li><a href=https://www.artima.com/insidejvm/ed2/jvmP.html target=_blank rel="noopener noreffer">https://www.artima.com/insidejvm/ed2/jvmP.html</a></li><li><a href=https://leeyh0216.github.io/2020-04-18/java_class_loader target=_blank rel="noopener noreffer">leeyh0216님의 블로그 - 자바의 클래스로더 알아보기</a></li><li><a href=https://www.baeldung.com/java-classloaders target=_blank rel="noopener noreffer">baeldung.com/java-classloaders</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-01-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://altera520.github.io/posts/2021-01-12-jvm/ data-title="JVM 구조" data-hashtags=Java><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://altera520.github.io/posts/2021-01-12-jvm/ data-hashtag=Java><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://altera520.github.io/posts/2021-01-12-jvm/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://altera520.github.io/posts/2021-01-12-jvm/ data-title="JVM 구조"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/java/>Java</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/2021-01-06-singleton/ class=prev rel=prev title=싱글턴(Singleton)>← </i>싱글턴(Singleton)</a>
<a href=/posts/2021-02-17-java8-features-1st/ class=next rel=next title="[Java8의 변경사항] 1. 특징 및 람다 표현식">[Java8의 변경사항] 1. 특징 및 람다 표현식 →</a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.75.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>altera520</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"title","label":"comment","lightTheme":"github-light","repo":"Altera520/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"Z6XUTBRBTU","algoliaIndex":"tech_blog","algoliaSearchKey":"93666bf981eb546301c54c0d60833095","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"algolia"}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-0HZQPQBVVJ',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-0HZQPQBVVJ" async></script></body></html>