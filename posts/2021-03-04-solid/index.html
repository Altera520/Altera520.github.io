<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>객체 지향 5대 원칙 - SOLID - altera520 Blog</title><meta name=Description content><meta property="og:title" content="객체 지향 5대 원칙 - SOLID"><meta property="og:description" content="SOLID란? OOP에서 클래스 안의 응집도(Cohesion)는 높이고 타 클래스 간의 결합도(Coupling)는 낮추는 관점에서 정립된 원칙을 말한다.
SOLID 원칙에 기반하여 소프트웨어를 개발하면 소프트웨어 내부 컴포넌트들은 재사용성이 높아지고 수정이 최소화되기 때문에 보다 유지보수하기 쉽고, 유현하고, 확장이 용이해진다.
 SRP 정의 단일책임 원칙이란 클래스는 단 하나의 책임을 가져야하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다는 원칙이다."><meta property="og:type" content="article"><meta property="og:url" content="https://altera520.github.io/posts/2021-03-04-solid/"><meta property="article:published_time" content="2021-03-04T19:19:08+09:00"><meta property="article:modified_time" content="2021-03-04T19:19:08+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="객체 지향 5대 원칙 - SOLID"><meta name=twitter:description content="SOLID란? OOP에서 클래스 안의 응집도(Cohesion)는 높이고 타 클래스 간의 결합도(Coupling)는 낮추는 관점에서 정립된 원칙을 말한다.
SOLID 원칙에 기반하여 소프트웨어를 개발하면 소프트웨어 내부 컴포넌트들은 재사용성이 높아지고 수정이 최소화되기 때문에 보다 유지보수하기 쉽고, 유현하고, 확장이 용이해진다.
 SRP 정의 단일책임 원칙이란 클래스는 단 하나의 책임을 가져야하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다는 원칙이다."><meta name=application-name content="altera520 Blog"><meta name=apple-mobile-web-app-title content="altera520 Blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://altera520.github.io/posts/2021-03-04-solid/><link rel=prev href=https://altera520.github.io/posts/2021-03-02-jdbc/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"객체 지향 5대 원칙 - SOLID","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/altera520.github.io\/posts\/2021-03-04-solid\/"},"genre":"posts","keywords":"SOLID","wordcount":1285,"url":"https:\/\/altera520.github.io\/posts\/2021-03-04-solid\/","datePublished":"2021-03-04T19:19:08+09:00","dateModified":"2021-03-04T19:19:08+09:00","publisher":{"@type":"Organization","name":"altera520"},"author":{"@type":"Person","name":"altera520"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('light'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'light'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=menu><div class=menu-inner><a class=menu-item href=/>Blog </a><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories</a></div></div><div class=menu><div class=menu-inner><span class="menu-item search" id=search-desktop><input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="altera520 Blog">altera520 Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/>Blog</a><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=intro-header id=intro><div class=post-blur></div><div class="page single"><div class=intro-header-title><div class=post-meta><span class=post-category><a href=/categories/oop/ id=custom-category>OOP</a></span></div><h1 class="single-title animated flipInX">객체 지향 5대 원칙 - SOLID</h1><div class=post-meta><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-03-04>2021-03-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1285 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;7 minutes&nbsp;</div></div></div></div></div><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><div class=content id=content><div class="details toc" id=toc-static kept><div class="details-summary toc-title"></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#solid란>SOLID란?</a></li><li><a href=#srp>SRP</a><ul><li><a href=#정의>정의</a></li><li><a href=#예시>예시</a></li></ul></li><li><a href=#ocp>OCP</a><ul><li><a href=#정의-1>정의</a></li><li><a href=#예시-1>예시</a></li></ul></li><li><a href=#lsp>LSP</a></li><li><a href=#isp>ISP</a><ul><li><a href=#정의-2>정의</a></li><li><a href=#예시-2>예시</a></li></ul></li><li><a href=#dip>DIP</a><ul><li><a href=#정의-3>정의</a></li><li><a href=#예시-3>예시</a></li></ul></li><li><a href=#ocp와-dip에서의-문제점>OCP와 DIP에서의 문제점</a></li><li><a href=#references>References</a></li></ul></nav></div></div><h2 id=solid란>SOLID란?</h2><p>OOP에서 클래스 안의 응집도(Cohesion)는 높이고 타 클래스 간의 결합도(Coupling)는 낮추는 관점에서 정립된 원칙을 말한다.</p><p>SOLID 원칙에 기반하여 소프트웨어를 개발하면 소프트웨어 내부 컴포넌트들은 재사용성이 높아지고 수정이 최소화되기 때문에 보다 유지보수하기 쉽고, 유현하고, 확장이 용이해진다.</p><br><h2 id=srp>SRP</h2><h3 id=정의>정의</h3><p>단일책임 원칙이란 <strong>클래스는 단 하나의 책임을 가져야하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다</strong>는 원칙이다.</p><p>하지만, 하나의 책임이라는 것은 실무에서 모호하다.<br>큰 책임과 상대적으로 작은 책임이 존재할 수 있는데 책임을 너무 크게 잡으면 클래스의 규모가 커지고, 책임을 너무 작게 잡으면 클래스들이 잘게 나눠진다.</p><ul><li>중요한 기준은 변경이다. 즉, <strong>변경의 이유</strong>가 <strong>책임의 기준</strong>이 된다.</li><li>변경이 있을 때, 하나의 지점이나 하나의 클래스만 변경하면 단일책임의 원칙을 잘 따른것이라 할 수 있다.</li></ul><br><h3 id=예시>예시</h3><div class=subject4>학교에서 학생 관리 시스템</div><a class=lightgallery href=/images/2021-03-04-solid/srp-1.png title=/images/2021-03-04-solid/srp-1.png data-thumbnail=/images/2021-03-04-solid/srp-1.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/srp-1.png data-srcset="/images/2021-03-04-solid/srp-1.png, /images/2021-03-04-solid/srp-1.png 1.5x, /images/2021-03-04-solid/srp-1.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/srp-1.png width=115></a><p>학생 클래스가 위와 같이 구성되어 있다고 할 때 학생 클래스는 과목에 대한 조회와 추가도 수행하면서 DB 관련 작업도 수행하는 등 너무 많은 책임을 가지고 있다.</p><p>또한, 학생 클래스는 여러 책임을 가지고 있으므로 학생 클래스를 직,간접적으로 사용하는 외부의 코드도 많을 수 밖에 없다.</p><ul><li>학생 정보를 DB에 기록하는 코드</li><li>학생의 수강과목을 가져와서 출력등의 로직을 수행하는 코드</li><li>학생의 성적표와 출력표를 사용하는 코드</li><li>&mldr;</li></ul><br><p>책임이 많기에 클래스 내부에서 서로 다른 역할을 수행하는 코드간에 결합이 강하게될 가능성도 높아진다.<br>따라서 학생 클래스의 특정 기능이 변경되면 테스트를 수행할 때 학생 클래스와 관계가 없더라도 직접 또는 간접적으로 사용하는 모든 코드를 <strong>회귀테스트</strong>해야 하는 문제점 또한 존재한다.</p><blockquote><p>회귀테스트란 시스템에서 어떤 변화가 있을 때 해당 변화가 기존의 시스템에 영향을 주는지 평가하는 테스트이다.</p></blockquote><br><p>학생 클래스의 책임을 최소화 시키고 모든 코드를 테스하는 문제를 해결하기 위해서는, 우선 학생 클래스가 언제 변경되어야 하는지 변경될 이유를 찾아봐야 한다.</p><ul><li>DB에서 학생 에 대응하는 스키마가 변경되면 학생 클래스는 변경되어야 하는가?</li><li>학생의 지도 교수를 찾는 기능이 추가되어야 한다면 학생 클래스는 변경되어야 하는가?</li><li>학생 정보를 출석부 이외의 정보로 출력해야 한다면 학생 클래스는 변경되어야 하는가?</li></ul><p>위 3가지 모두가 클래스를 변경해야 하는 이유가 되므로 이를 바탕으로 책임을 분리하도록 한다.</p><ul><li>학생의 고유 정보</li><li>DB 스키마</li><li>출력 형식의 변화</li></ul><a class=lightgallery href=/images/2021-03-04-solid/srp-2.png title=/images/2021-03-04-solid/srp-2.png data-thumbnail=/images/2021-03-04-solid/srp-2.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/srp-2.png data-srcset="/images/2021-03-04-solid/srp-2.png, /images/2021-03-04-solid/srp-2.png 1.5x, /images/2021-03-04-solid/srp-2.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/srp-2.png width=300></a><p>변경 이유에 따라 기존 클래스의 책임을 나누어 여러 클래스로 분리했을 때, 학생 클래스는 학생 고유의 책임만 가지도록 하고 학생 정보의 DB와 관련된 처리는 학생 DAO에서, 출력 형식을 처리하는 클래스는 성적표 클래스와 출석부 클래스로 분리하였다.</p><p>위와 같이 분리함으로서, DB와 관련된 부분에서 변경이 발생하면 학생 DAO 클래스와 해당 클래스를 사용하는 클래스들만 영향을 받으므로 <strong>변경에 따른 클래스들간의 영향을 최소화 시킬 수 있다.</strong></p><br><h2 id=ocp>OCP</h2><h3 id=정의-1>정의</h3><p>개방폐쇄 원칙은 <strong>확장에는 열려있고 변경에는 닫혀 있어야</strong>하는 원칙이다. 즉, 새로운 기능을 추가할 때 기존의 원본 클래스가 변경되지 않고도 대상 클래스의 환경을 변경할 수 있어야 한다.</p><p>OCP를 따름으로서 기존 코드를 유지보수하기 쉽게 만들어 기능확장성에 대해 고려할 때 매우 편해지며, OCP는 DIP와 밀접되어 있다.<br>OOP에서 OCP는 크게 두 방법으로 구현할 수 있다.</p><ul><li><strong>상속을 통한 구현</strong>: 클래스를 상속시켜 확장시키거나 새로운 클래스에서 인터페이스를 구현한다.</li><li><strong>조립을 통한 구현</strong>: 조립과 DIP, 상속이 서로 맞물리는 방법으로 구현한다.</li></ul><br><h3 id=예시-1>예시</h3><div class=subject4>프론트 컨트롤러 패턴</div><div class=subject5>OCP를 위배하는 경우</div><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>URLMapper</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>mapping</span><span class=o>(</span><span class=n>String</span> <span class=n>url</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=s>&#34;shopping.do&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>url</span><span class=o>))</span> <span class=o>{</span>
            <span class=k>return</span> <span class=s>&#34;shopping&#34;</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=s>&#34;login.do&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>url</span><span class=o>))</span> <span class=o>{</span>
            <span class=k>return</span> <span class=s>&#34;login&#34;</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=s>&#34;mypage.do&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>url</span><span class=o>))</span> <span class=o>{</span>
            <span class=k>return</span> <span class=s>&#34;mypage&#34;</span><span class=o>;</span>
        <span class=o>}</span>
 
        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;No Matched URL&#34;</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>위의 코드에서는 <code>URLMapper</code> 클래스에서 인자로 들어온 url과 대응되는 페이지명을 반환시켜주고 있다.</p><p>하지만, 새로운 url이 추가될 경우 <code>mapping</code> 메서드의 내부에 else-if 문을 추가해야할 것이다. 이 경우 <code>URLMapper</code> 클래스의 변경이 불가피해지게 되어 위의 코드는 OCP를 위배하게된다.</p><br><div class=subject5>OCP를 위배하는 경우에서 리팩토링</div><p>새로운 url이 추가(확장)되어도 기존의 <code>URLMapper</code>가 변경되지 않도록 해야 OCP를 성립시킬 수 있을 것이다.</p><p>url 정보를 처리하는 enum 객체를 별도로 구성하고, <code>URLMapper</code>에서는 enum 객체의 <code>matchOf</code> 메서드에 파라미터로 url을 넘겨 일치하는 페이지명을 반환받도록 구성하면 새로운 페이지가 추가되더라도 <code>URLMapper</code> 클래스의 변경은 일어나지 않는다.</p><p>하지만 새로운 페이지가 추가되면 <code>URL</code>의 코드는 수정이 불가피하다. 즉 완전히 OCP를 성립시키기가 힘들다.<br>해당 문제점에 대해서는 <a href=/posts/2021-03-04-solid/#ocp%ec%99%80-dip%ec%97%90%ec%84%9c%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90 rel>OCP와 DIP에서의 문제점</a>에서 언급하도록 한다.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>enum</span> <span class=n>URL</span> <span class=o>{</span>
    <span class=n>SHOPPING</span><span class=o>(</span><span class=s>&#34;shopping.do&#34;</span><span class=o>,</span> <span class=s>&#34;shopping&#34;</span><span class=o>),</span>
    <span class=n>LOGIN</span><span class=o>(</span><span class=s>&#34;login.do&#34;</span><span class=o>,</span> <span class=s>&#34;login&#34;</span><span class=o>),</span>
    <span class=n>MY_PAGE</span><span class=o>(</span><span class=s>&#34;mypage.do&#34;</span><span class=o>,</span> <span class=s>&#34;mypage&#34;</span><span class=o>),</span>
 
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>url</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>matchResult</span><span class=o>;</span>
 
    <span class=n>URL</span><span class=o>(</span><span class=kd>final</span> <span class=n>String</span> <span class=n>url</span><span class=o>,</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>matchResult</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>url</span> <span class=o>=</span> <span class=n>url</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>matchResult</span> <span class=o>=</span> <span class=n>matchResult</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=n>URL</span> <span class=nf>matchOf</span><span class=o>(</span><span class=n>String</span> <span class=n>url</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>values</span><span class=o>())</span>
            <span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>urls</span> <span class=o>-&gt;</span> <span class=n>urls</span><span class=o>.</span><span class=na>match</span><span class=o>(</span><span class=n>url</span><span class=o>))</span>
            <span class=o>.</span><span class=na>findFirst</span><span class=o>()</span>
            <span class=o>.</span><span class=na>orElseThrow</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;해당하는 url이 없습니다&#34;</span><span class=o>));</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getMatchResult</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>matchResult</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=o>...</span>
<span class=o>}</span>

<span class=o>...</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>URLMapper</span> <span class=o>{</span>
	<span class=kd>public</span> <span class=n>String</span> <span class=nf>urlMapping</span><span class=o>(</span><span class=n>String</span> <span class=n>url</span><span class=o>)</span> <span class=o>{</span>
		<span class=k>return</span> <span class=n>URL</span><span class=o>.</span><span class=na>matchOf</span><span class=o>(</span><span class=n>url</span><span class=o>)</span>
                <span class=o>.</span><span class=na>getMatchResult</span><span class=o>();</span>
	<span class=o>}</span>
<span class=o>}</span>
</code></pre></div><br><h2 id=lsp>LSP</h2><p>리스코프 치환 원칙은 <strong>상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 정확성은 깨지지 않아야 한다</strong>는 원칙이다.</p><p>즉, 하위 타입 객체가 상위 타입 객체의 역할을 대신해도 프로그램은 정의된 규약대로 정상 동작해야한다는 것이다.</p><p>LSP를 만족시키는 가장 간단한 방법은 하위 타입에서 상위 타입의 기능을 재정의(override)하지 않는다는 것이다.<br>혹여나 재정의를 하더라도 재정의된 동작은 필히 기존에 명세된 규약대로 동작해야하며 기존과 동일한 프로그램 동작을 보장해야한다.</p><br><h2 id=isp>ISP</h2><h3 id=정의-2>정의</h3><p>인터페이스 분리 원칙은 <strong>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다</strong>는 원칙이다.
즉, 특정 클라이언트를 위한 여러개의 인터페이스가 범용 인터페이스 하나보다 낫다는 것이다.</p><br><p>ISP는 SRP와 유사하나 동일한 문제에 대해 다른 해결방식을 취한다는 점에서 차이가 있다.</p><ul><li>SRP는 하나의 클래스가 책임이 크다면 책임을 분할하여 작은 클래스들로 나눈다.</li><li>ISP는 클래스를 분리하는 것이 아닌, 클래스의 역할을 명시하고 있는 인터페이스를 여러개의 인터페이스로 분리한다.</li></ul><p>위와 같이 방식의 차이점도 존재하며, ISP는 SRP를 만족하면 무조건적으로 성립되는 것이 아님에 유의한다.
<a class=lightgallery href=/images/2021-03-04-solid/isp-0.png title=/images/2021-03-04-solid/isp-0.png data-thumbnail=/images/2021-03-04-solid/isp-0.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/isp-0.png data-srcset="/images/2021-03-04-solid/isp-0.png, /images/2021-03-04-solid/isp-0.png 1.5x, /images/2021-03-04-solid/isp-0.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/isp-0.png width=320></a></p><ul><li>게시판 클래스는 게시판과 관련된 책임을 수행하므로 SRP 성립</li><li>관리자만 게시판 삭제 기능을 사용할 수 있다고 했을 때, 일반 사용자도 삭제 기능을 사용할 수 있으므로 ISP 성립하지 않음</li></ul><br><h3 id=예시-2>예시</h3><div class=subject4>자동차 시스템</div><div class=subject5>ISP를 위배하는 경우</div><a class=lightgallery href=/images/2021-03-04-solid/isp-1.png title=/images/2021-03-04-solid/isp-1.png data-thumbnail=/images/2021-03-04-solid/isp-1.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/isp-1.png data-srcset="/images/2021-03-04-solid/isp-1.png, /images/2021-03-04-solid/isp-1.png 1.5x, /images/2021-03-04-solid/isp-1.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/isp-1.png width=320></a><p>현실 세계의 자동차를 예시로 들고자 한다.<br>자동차라는 역할에 &lsquo;운전&rsquo; 과 &lsquo;정비&rsquo; 가 포함되어있고 자동차를 사용하는 클라이언트는 &lsquo;일반 운전자&rsquo; 와 &lsquo;정비사&rsquo; 가 있다. 다이어그램이 위와 같이 구성되어있을 때 다음과 같은 문제점이 존재한다.</p><ul><li>자동차의 모든 기능을 &lsquo;일반 운전자&rsquo; 와 &lsquo;정비사&rsquo; 클라이언트가 동시에 사용하는 경우는 거의 없다.</li><li><code>move</code> 기능 변경으로 인해 자동차 정비를 수행하는 정비사 클라이언트가 영향을 받을 수 있다.</li></ul><br><div class=subject5>ISP를 위배하는 경우에서 리팩토링</div><p>ISP 원칙을 적용하여 하나의 범용 인터페이스를 여러개의 인터페이스로 분리하면 위의 문제점을 해결하는 것이 가능하다.</p><a class=lightgallery href=/images/2021-03-04-solid/isp-2.png title=/images/2021-03-04-solid/isp-2.png data-thumbnail=/images/2021-03-04-solid/isp-2.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/isp-2.png data-srcset="/images/2021-03-04-solid/isp-2.png, /images/2021-03-04-solid/isp-2.png 1.5x, /images/2021-03-04-solid/isp-2.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/isp-2.png width=320></a><p>이렇게 함으로서, 정비 인터페이스가 추후 변경이된다 하더라도 운전자 클라이언트에게 영향을 미치지 않는다.<br>또한 인터페이스가 명확해지고 각 인터페이스들의 대체가능성 또한 높아진다는 장점을 가질 수 있다.</p><br><h2 id=dip>DIP</h2><h3 id=정의-3>정의</h3><p>의존성 역전 원칙이란 <strong>상위 모듈은 하위 모듈에 의존하면 안된다</strong>라는 원칙이다.</p><p>즉, 구체화된 <strong>구현체(클래스)</strong> 가 아닌 추상화된 <strong>역할(인터페이스)</strong> 에 의존하라는 것이다. 구현에 의존하게 되면 변경이 아주 어려워진다.</p><p>DIP를 따르게되면 확장성이 용이해지고 객체간의 결합도가 낮아져 기존의 구현체를 언제든 다른 구현체로 교체할 수 있는등의 장점을 가진다.</p><br><h3 id=예시-3>예시</h3><div class=subject4>결제 수단에 따라 결제를 수행하는 시스템</div><div class=subject5>DIP를 위배하는 경우</div><a class=lightgallery href=/images/2021-03-04-solid/dip-1.png title=/images/2021-03-04-solid/dip-1.png data-thumbnail=/images/2021-03-04-solid/dip-1.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/dip-1.png data-srcset="/images/2021-03-04-solid/dip-1.png, /images/2021-03-04-solid/dip-1.png 1.5x, /images/2021-03-04-solid/dip-1.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/dip-1.png width=270></a><p><code>PayService</code>라는 클래스는 <code>SamsungPay</code>라는 클래스에 의존하고 있다. 즉, DIP를 위배하고 있다.</p><p>추후에 <code>PayService</code>에서 결제를 위해 처리하는 지불 수단이 <code>KakaoPay</code>나 <code>NaverPay</code>로 변경되어야 한다고 했을때, 상위 모듈과 하위모듈의 결합도가 높으므로 변경이 쉽지 않을 수 있다.</p><br><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm>* 상위모듈(PayService)이 하위모듈(SamsungPay)에 의존적
</span><span class=cm>*/</span>
<span class=kd>class</span> <span class=nc>SamsungPay</span> <span class=o>{</span>
    <span class=n>String</span> <span class=nf>payment</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34;samsung&#34;</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=o>...</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>PayService</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>SamsungPay</span> <span class=n>pay</span><span class=o>;</span>
 
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setPay</span><span class=o>(</span><span class=kd>final</span> <span class=n>SamsungPay</span> <span class=n>pay</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>pay</span> <span class=o>=</span> <span class=n>pay</span><span class=o>;</span>
    <span class=o>}</span>
 
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>payment</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>pay</span><span class=o>.</span><span class=na>payment</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><br><div class=subject5>DIP를 위배하는 경우에서 리팩토링</div><a class=lightgallery href=/images/2021-03-04-solid/dip-2.png title=/images/2021-03-04-solid/dip-2.png data-thumbnail=/images/2021-03-04-solid/dip-2.png><img class=lazyload src=/svg/loading.min.svg data-src=/images/2021-03-04-solid/dip-2.png data-srcset="/images/2021-03-04-solid/dip-2.png, /images/2021-03-04-solid/dip-2.png 1.5x, /images/2021-03-04-solid/dip-2.png 2x" data-sizes=auto alt=/images/2021-03-04-solid/dip-2.png width=390></a><p>앞선 DIP를 위배하는 코드에서 하위 모듈과의 결합도를 낮추기 위해서는 지불이라는 역할(role)에 대한 명세를 나타내는 인터페이스를 정의하고, 상위 모듈에서는 해당 인터페이스를 바탕으로 하여 구현체를 사용해야한다.</p><p>리팩토링한 코드에서는, 지불이라는 역할에 대한 명세로 <code>Pay</code>를 정의하였고 <code>SamsungPay</code>라는 구현체는 <code>Pay</code>의 <code>payment</code>를 구현하고 있다.
상위 모듈에서는 <code>SamsungPay</code>라는 구현체를 의존적으로 바로 사용하는 것이 아닌, <code>Pay</code>라는 역할을 바탕으로하여 내부 로직을 처리하고 있다.</p><p>이렇게 코드를 리팩토링함으로서, 추후 <code>SamsungPay</code>대신 다른 지불 수단으로 변경되어도<br>새로운 구현체는 <code>Pay</code>의 역할만 구현하면 되므로 <code>PayService</code>에서는 별도의 처리를 하지않더라도 얼마든지 다른 구현체를 사용할 수 있게되므로 DIP가 성립한다.</p><br><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>//공통 부분 추상화한 역할 정의
</span><span class=c1></span><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Pay</span> <span class=o>{</span>
    <span class=n>String</span> <span class=nf>payment</span><span class=o>();</span>
<span class=o>}</span>

<span class=o>...</span>

<span class=kd>class</span> <span class=nc>SamsungPay</span> <span class=kd>implements</span> <span class=n>Pay</span> <span class=o>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>payment</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34;samsung&#34;</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=o>...</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>PayService</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>Pay</span> <span class=n>pay</span><span class=o>;</span>
 
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setPay</span><span class=o>(</span><span class=kd>final</span> <span class=n>Pay</span> <span class=n>pay</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>pay</span> <span class=o>=</span> <span class=n>pay</span><span class=o>;</span>
    <span class=o>}</span>
 
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>payment</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>pay</span><span class=o>.</span><span class=na>payment</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><br><h2 id=ocp와-dip에서의-문제점>OCP와 DIP에서의 문제점</h2><p>SOLID 원칙을 따르면 서두에서 기술한대로 응집도는 높아지고 결합도가 낮아져 소프트웨어를 보다 유연하고 확장성있게 구성할 수 있다는 장점을 가진다.</p><p>하지만, 앞서 OCP의 예제에서는 페이지가 추가되면 URL에 대응하는 열거 자료를 추가해줘야만 할것이다.</p><p>또한 DIP의 예시로 들었던 <code>PayService</code>의 경우 <code>PayService</code>에 <code>SamsungPay</code>나 <code>KakaoPay</code>등을 설정해줄 수 있는 외부의 클라이언트 객체에서는 지불 수단이 바뀔 경우 아래와 같이 코드를 변경시켜줘야할 것이다.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>payService</span><span class=o>.</span><span class=na>setPay</span><span class=o>(</span><span class=k>new</span> <span class=n>SamsungPay</span><span class=o>());</span>
<span class=n>payService</span><span class=o>.</span><span class=na>setPay</span><span class=o>(</span><span class=k>new</span> <span class=n>KakaoPay</span><span class=o>());</span>
</code></pre></div><br><p>즉, 다형성 만으로는 구현 객체를 변경했을 때 클라이언트 코드도 함께 변경되는 문제점이 있으며 순수한 자바만으로 객체지향 원칙을 지켜가면서 프로그래밍하자니 OCP랑 DIP를 완전히 지킬 수 없다는 결론이 나온다.</p><p><strong>Spring 프레임워크는 IoC 컨테이너와 DI라는 기술을 통해 OCP와 DIP를 가능하게 지원하여 클라이언트의 코드 변경 없이 기능을 확장 시킬수 있게 하였다.</strong></p><br><h2 id=references>References</h2><ul><li><a href=https://doublem.org/SOLID_SRP_OCP/ target=_blank rel="noopener noreffer">https://doublem.org/SOLID_SRP_OCP/</a></li><li><a href=https://limkydev.tistory.com/77 target=_blank rel="noopener noreffer">https://limkydev.tistory.com/77</a></li><li><a href=https://gmlwjd9405.github.io/2018/07/05/oop-solid.html target=_blank rel="noopener noreffer">https://gmlwjd9405.github.io/2018/07/05/oop-solid.html</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-03-04</span></div><div class=post-info-license></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/solid/>SOLID</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/2021-03-02-jdbc/ class=prev rel=prev title="자바의 JDBC">← </i>자바의 JDBC</a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.75.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>altera520</a></span></div><div class=links><a href=https://github.com/Altera520 title=GitHub target=_blank rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href=https://www.instagram.com/gj__an title=Instagram target=_blank rel="noopener noreffer me"><i class="fab fa-instagram fa-fw"></i></a><a href=mailto:sencom1028@gmail.com title=Email rel=me><i class="far fa-envelope fa-fw"></i></a><a href=/index.xml title=RSS target=_blank rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"title","label":"comment","lightTheme":"github-light","repo":"Altera520/blog-comment"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"Z6XUTBRBTU","algoliaIndex":"tech_blog","algoliaSearchKey":"93666bf981eb546301c54c0d60833095","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"algolia"}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-0HZQPQBVVJ',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-0HZQPQBVVJ" async></script></body></html>