[{"categories":["Programming"],"content":"JDBC 정의 JDBC는 자바 언어를 통해 다양한 DB에 접속하여 SQL문 수행이 가능한 표준 SQL 인터페이스를 말하며 모든 자바의 Data Access 기술의 근간이다. JDBC Architecture\"\rJDBC Architecture\r JDBC를 사용하지 않는다면, DBMS의 종류가 다양하고 DBMS마다 대응하는 API를 개발해야할 것이다. 이러한 수고로움과 불편함을 덜기위해 모든 DBMS에서 공통적으로 사용가능한 인터페이스와 클래스를 포함한 JDBC API 규격을 정의하였다. 실제 클래스의 구현은 각 DBMS 벤더가 구현한다. Java SE에서 제공하는 java.sql 패키지를 통해 JDBC를 다룰 수 있으며 사전에 접속하려는 DBMS의 JDBC 드라이버가 필요하다. ","date":"2021-03-02","objectID":"/posts/2021-03-02-jdbc/:1:0","tags":["Java","JDBC"],"title":"자바의 JDBC","uri":"/posts/2021-03-02-jdbc/"},{"categories":["Programming"],"content":"JDBC 수행 단계 JDBC 수행 단계는 5단계로 나뉜다. (드라이버 로드 → DBMS와 연결 → Statement 생성 → Statement 전송 → 자원해제) 1. JDBC 드라이버 로드\r java.lang.Class에서 제공하는 forName 메서드를 사용한다. forName의 인자로 드라이버 파일안의 JDBC 드라이버 인터페이스를 상속하고 있는 클래스의 FQCN을 기입토록한다. forName메서드를 통해 런타임시 동적로딩하여 드라이버 인스턴스를 생성한다. Class.forName(\"oracle.jdbc.driver.OracleDriver\"); // ORACLE 드라이버 인스턴스 생성 2. DBMS와 연결\r DBMS와의 커넥션(Connection)을 생성하는 단계다. getConnection 메서드에 파라미터로 URL(protocol, host, port, scheme)과 DB의 사용자 ID 및 패스워드를 전달하여 데이터베이스와 연결하며, 연결에 성공하면 Connection 객체를 반환해준다. Connection conn = DriverManager.getConnection( \"jdbc:oracle:thin@localhost:1521:xe\", // 접속할 DBMS 서버의 URL \"scott\", // DB의 사용자 ID \"tiger\" // DB의 사용자 password ); 하지만, 위의 방식을 통해 매 요청마다 커넥션을 위한 리소스를 생성하는 것은 서버의 오버헤드를 가중시킨다. 따라서 매 요청마다 커넥션을 생성하는 것이 아닌, 커넥션 풀(Connection Pool, DBCP) 을 통해 미리 커넥션들을 준비해놓고 필요할때마다 커넥션을 가져다 쓰는 방식이 권장된다. 커넥션 풀의 설정\r 커넥션 풀을 사용하기 위해서는 아래의 단계가 선행되어야 한다. server.xml에 \u003cResource\u003e 추가 \u003cGlobalNamingResource\u003e ... \u003cResource driverClassName=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin@localhost:1521:xe\" username=\"scott\" password=\"tiger\" name=\"jdbc/mydbms\" type=\"javax.sql.DataSource\" maxActive=\"4\" maxIdle=\"2\" maxWait=\"5000\" /\u003e \u003c/GlobalNamingResource\u003e name: 리소스의 이름 maxActive: 생성할 Connection 갯수 maxIdle: 일반적으로 활용할 커넥션 갯수 maxWait: 커넥션 요청 시 대기 시간(ms), 대기 시간이 지난 후에도 커넥션을 얻지못하면 예외 발생 context.xml에 \u003cResourceLink\u003e 등록 \u003cResourceLink global=\"jdbc/mydbms\" name=\"jdbc/mydbms\" type=\"javax.sql.DataSource\" /\u003e 서버의 리소스를 웹 애플리케이션에서 찾아서 사용할 수 있도록 글로벌한 이름을 지정하는 단계이다. WEB-INF/web.xml에 resource-ref 등록[1] DataSource의 사용\r DataSource는 JDBC 명세의 일부분이며 일반화된 커넥션 팩토리이다. DataSource는 JDBC Driver의 벤더사 별로 여러 종류가 존재하며, DB 서버와의 연결 및 커넥션 풀링 기능들을 수행해준다. DataSource를 이용한 커넥션 사용 방법은 아래의 절차를 거친다. JNDI에서 lookup메서드를 통해 DataSource 객체를 획득한다. DataSource 객체의 getConnection메서드를 통해 커넥션 풀에서 유휴 상태의 커넥션을 획득한다. 커넥션을 통한 DB 작업을 수행한다. 모든 작업 완료시 획득한 커넥션을 커넥션 풀에 반납한다. // 1. JNDI 서버 객체 생성 InitialContext ic = new InitialContext(); // 2. Look up DataSource ds = (DataSource) ic.lookup(\"java:comp/env/jdbc/orcl\"); ... // 3. get Connection Connection conn = ds.getConnection(); 3. SQL Statement 생성\r SQL 구문을 담아서 커넥션을 통해 DBMS에게 전달할 객체를 생성하는 단계다. 해당 단계에서는 Statement나 PreparedStatement를 사용할 수 있다. PreparedStatement의 경우 ?기호를 통해 동적으로 데이터를 할당할 수 있어 코드의 가독성이 좋아진다는 장점이 있다. // Statement 사용 Statement stmt = conn.createStatement(); stmt.executeUpdate(\"INSERT INTO STUDENT VALUES ('\"+ id +\"','\"+ pwd +\"')\"); // PreparedStatement 사용 PreparedStatement pstmt = conn.prepareStatement(\"INSERT INTO STUDENT VALUES (?, ?)\"); pstmt.setString(1, id); pstmt.setString(2, pwd); pstmt.executeUpdate(); 3. SQL Statement 전송\r Statement나 PreparedStatement 객체를 통해 사용할 수 있는 대표적인 메서드는 다음과 같다 executeQuery : SELECT를 하기 위해 사용하며 수행의 결과로 ResultSet 객체를 반환한다. excuteUpdate : INSERT, DELETE 등을 위해 사용한다. 4. 자원 해제\r DB에 CRUD를 수행하기 위해 사용하였던 리소드 객체들을 해제해주는 단계이다. 해당 단계에서는 생성한 리소스들의 역순으로 해제해주면된다. ResultSet Statement 또는 PreparedStatement Connection ... // 쿼리 수행 ResultSet rs = stmt.executeQuery(\"SELECT * FROM STUDENT\"); // 자원해제 rs.close(); stmt.close(); conn.close(); ","date":"2021-03-02","objectID":"/posts/2021-03-02-jdbc/:2:0","tags":["Java","JDBC"],"title":"자바의 JDBC","uri":"/posts/2021-03-02-jdbc/"},{"categories":["Programming"],"content":"JDBC의 문제점 JDBC를 통해 개발자는 일관된 API를 통해 다양한 관계형 DBMS를 다룰 수 있다는 장점이 존재하나, JDBC에는 다음과 같은 문제점들이 존재한다. 간단한 SQL문을 수행하더라도 중복된 코드의 반복적인 사용 (커넥션 생성, 리소스 해제, …) 데이터베이스 CRUD 로직에서 예외 처리 코드를 수행 트랜잭션의 처리 JDBC의 이러한 단점을 극복하고 장점은 유지하기위해 Spring의 JDBC는 반복적으로 처리해야하는 작업들을 JDBC Template등을 통해 대신 수행해주며, 이외에도 기존의 JDBC보다 편리한 기능들을 제공한다. ","date":"2021-03-02","objectID":"/posts/2021-03-02-jdbc/:3:0","tags":["Java","JDBC"],"title":"자바의 JDBC","uri":"/posts/2021-03-02-jdbc/"},{"categories":["Programming"],"content":"footnote [1] 톰캣 6.0 이후 부터는 설정해줄 필요가 없다. ","date":"2021-03-02","objectID":"/posts/2021-03-02-jdbc/:4:0","tags":["Java","JDBC"],"title":"자바의 JDBC","uri":"/posts/2021-03-02-jdbc/"},{"categories":["Programming"],"content":"References https://www.tutorialspoint.com/jdbc/index.htm ","date":"2021-03-02","objectID":"/posts/2021-03-02-jdbc/:5:0","tags":["Java","JDBC"],"title":"자바의 JDBC","uri":"/posts/2021-03-02-jdbc/"},{"categories":["Programming"],"content":"JSP란? JSP는 HTML에 자바 코드를 삽입하여 동적 컨텐츠를 생성하게 해주는 Server Side의 기술이자 스크립트 언어이다. Servlet과는 기능적인 측면에서의 차이는 없다. JSP가 서블릿 클래스로 변환되어 서블릿으로서 동작하기 때문이다. ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:1:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"JSP의 동작 과정 JSP의 동작은 변환 단계와 실행 단계로 나뉜다. 변환(Translation): JSP파일을 해석하여 서블릿 소스파일(.java)로 만들고 컴파일하여 서블릿 클래스(.class)를 생성한다. 변환과 컴파일 작업은 최초의 요청이거나 JSP가 변경되었을때만 수행된다. 실행(Execution): JSP파일에 대한 요청이 있을때마다 수행된다. 변환단계를 거쳐 생성된 서블릿 클래스(.class)를 통해 서블릿 객체를 생성하고 초기화하며, 생성된 서블릿 객체를 통해 요청을 처리하고 응답한다. JSP life cycle (출처:geeksforgeeks.org/life-cycle-of-jsp/)\"\rJSP life cycle (출처:geeksforgeeks.org/life-cycle-of-jsp/)\r 클라이언트로부터 JSP파일에 대한 요청이 들어오면 Jasper는 JSP 파일을 서블릿 파일(.java)로 변환시킨다. Jasper는 서블릿 파일을 컴파일하여 서블릿 클래스(.class)를 생성한다. 컴파일된 서블릿 클래스(.class)는 서블릿 컨테이너에 의해 서블릿 객체로 동작한다. jspInit 메서드를 통해 서블릿을 초기화하고, _jspService메서드를 통해 요청을 처리하고 응답하며, jspDestroy를 통해 서블릿 객체를 소멸시킨다. ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:2:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"JSP의 사용 JSP는 JSP의 구문 요소들을 통해 HTML과 같은 정적인 요소들과함께 작성된다. 스크립트 기반 태그, XML 기반의 표준 액션 태그 및 커스텀 태그, 내장객체, EL, JSTL을 JSP 내에서 조합하여 사용가능하다. ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"스크립트 기반 태그 1. 표현식(Expression)\r \u003c%= expression %\u003e 표현식 요소는 String으로 변환되어 서블릿의 출력에 삽입되며, 동적인 데이터를 응답 결과에 포함하기 위해 사용한다. 표현식 내의 자바 코드끝에 세미콜론(;)을 붙이지 않음을 유념한다. 2. 선언문(Declaration)\r \u003c%! declaration %\u003e 선언문은 메서드나 멤버변수를 선언하기 위해 사용한다. 3. 스크립트릿(Scriptlet)\r \u003c% code fragment %\u003e 자바 코드를 삽입하여 로직처리를 위해 사용하며 _jspService 메서드 내에 그대로 옮겨진다. 스크립트릿은 지역변수만 선언할 수 있다. (메서드는 정의할 수 없다.) 4. 주석문(Comment)\r JSP의 주석문이라 함은 \u003c%-- comment --%\u003e를 말하는 것이다. JSP 파일에서는 JSP의 주석문을 포함하여 3종류의 주석문을 사용할 수 있다. 종류 구문 주석으로 처리되는 시점 JSP 주석 \u003c%-- ... --%\u003e 서블릿 코드로 변환될 때 HTML 주석 \u003c!-- ... --\u003e 브라우저에 의해 응답이 파싱될 때 자바 주석 //, /* ... */ 서블릿 소스(.java)가 컴파일될 때 5. 지시자(Directive)\r 지시자는 JSP를 자바 코드로 변환하는데 필요한 정보를 설정하기 위해 사용한다. 클라이언트로의 출력이나 동적 데이터를 생성하기 위한 구문이 아니다. 지시자의 종류로는 page, include, taglib가 있다. page 지시자\r \u003c%@ page attribute = \"value\" %\u003e page 지시자는 JSP 페이지에 종속적인 설정 정보들을 알려주기 위해 사용한다. page 지시자에 설정가능한 대표적인 속성 name description contentType 클라이언트에게 전송되는 문서의 타입과 인코딩 타입을 지정하기위해 사용한다. import JSP내에 패키지를 임포트하기위해 사용한다. import JSP내에 패키지를 임포트하기위해 사용한다. isErrorPage 해당 JSP 페이지는 예외를 처리하기 위한 페이지임을 지정한다. errorPage 현재 JSP 페이지 실행 중 예외가 발생하면 errorPage에 지정된 페이지를 실행시킨다. session 해당 JSP 페이지의 세션 관리 및 처리 여부를 지정한다. 디폴트는 true이기에 페이지는 자동으로 세션을 생성한다. include 지시자\r \u003c%@ include file = \"JSP 파일명\" %\u003e JSP파일이 서블릿 코드로 변환될 때 include에 지정된 다른 JSP 파일을 병합할 때 사용한다.(정적) taglib 지시자\r \u003c%@ taglib uri = \"uri\" prefix = \"prefixOfTag\" %\u003e taglib 지시자는 커스텀 태그를 JSP내에 사용할 수 있게 해준다. 자바에서 package를 import하여 쓰는것처럼 위의 구문을 통해 사용하고자 하는 커스텀 태그를 포함시킨다. ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:1","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"표준 액션 태그(Action) 표준 액션 태그는 JSP 파일 내에서 \u003c태그 라이브러리 이름 : 태그 이름\u003e 형식의 XML 문법 형태로 사용된다. 표준 액션 태그는 미리 정해진 기능들을 JSP 스펙에 명시함으로서 모든 WAS의 컨테이너가 동일하게 구현하는 태그를 말한다. 주로 사용되는 표준 액션 태그는 다음과 같으며 더 자세한 예시는 www.javatpoint.com을 참고토록한다. 1. \u003cjsp:forward\u003e\r 서블릿에서 RequestDispatcher객체의 forward 메서드 기능을 수행한다. 즉, 다른 페이지로 이동할 때 사용하는 태그다. \u003cjsp:forward page=\"path\"/\u003e \u003cjsp:forward page=\"\u003c%= %\u003e\"/\u003e 2. \u003cjsp:include\u003e\r 서블릿에서 RequestDispatcher객체의 include 메서드 기능을 수행한다. 다른 페이지를 현재 페이지에 포함할 때 사용하는 태그다. include 액션 태그는 include 지시자와 동작 방식에서 차이가 있다. include 지시자: JSP 파일에서 자바 코드로 변환될 때 페이지가 포함된다.(정적) include 액션 태그: 코드가 실행될 때 포함된다.(동적) \u003cjsp:include page=\"path\"/\u003e \u003cjsp:include page=\"\u003c%= %\u003e\"/\u003e 3. \u003cjsp:useBean\u003e\r Bean(자바 객체)을 생성하거나 이미 생성된 객체를 추출하는 기능을 수행한다. \u003cjsp:useBean\u003e을 사용하기 이전에 자바 빈이 사전에 정의되어 있어야 하며 디폴트 패키지에 위치해 있으면 인식이 안된다. 또한 기본 생성자를 통해 빈을 생성하고 프로퍼티를 사용하므로 빈의 정의에는 기본생성자, setter/getter가 포함되어야 한다. \u003c!-- SampleBean sample = new SampleBean(); --\u003e \u003cjsp:useBean id=\"sample\" class=\"com.edu.beans.SampleBean\"/\u003e id: 객체를 식별하기 위한 고유한 이름 지정 class: Bean의 FQCN(Fully Qualified Class Name) 기입 type: Bean에 접근하는 참조변수의 타입을 설정한다. 디폴트는 현재 타입이지만 타입을 지정하면 부모 타입으로 접근가능하다. scope: Bean의 유효범위 설정. 4개의 속성 값 중 하나로 지정하며 디폴트로 page가 적용됨 page: 하나의 JSP 페이지 내에서만 사용 request: 요청이 처리되는 동안 forward, include된 페이지들 간에서도 사용 session: 클라이언트 단위로 사용 application: 웹 애플리케이션 단위로 사용 4. \u003cjsp:setProperty\u003e\r Bean의 setter 메서드를 통해 속성을 설정한다. \u003cjsp:setProperty name=\"...\" property=\"...\" value=\"...\"/\u003e \u003cjsp:setProperty name=\"...\" property=\"...\" param=\"...\"/\u003e name: \u003cjsp:useBean\u003e에서 정의해둔 id 속성값 property[1]: Bean의 멤버변수 이름 value: Bean의 속성을 변경하려는 값. value가 생략되면 쿼리스트링의 파라미터와 Bean의 멤버변수와 같은 이름을 찾아서 자동으로 바인딩 시킨다. param: 쿼리스트링의 parameter 속성 이름 기입. 쿼리스트링에 포함된 parameter 속성에 할당된 값으로 Bean의 속성값 설정 5. \u003cjsp:getProperty\u003e\r Bean의 getter 메서드를 통해 속성값을 가져오는데 사용한다. \u003cjsp:getProperty name=\"...\" property=\"...\"/\u003e name: \u003cjsp:useBean\u003e에서 정의해둔 id 속성값 property: Bean의 멤버변수 이름 ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:2","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"내장 객체 _jspService 메서드 내에 자동으로 선언 및 초기화가 되는 지역변수들을 내장 객체라고 한다. 내장 객체는 JSP 파일에서 별도의 선언 및 초기화 없이 바로 사용 가능하다. JSP의 내장 객체 name type description request javax.servlet.http.HttpServletRequest 요청정보 처리 객체 response javax.servlet.http.HttpServletResponse 응답정보 처리 객체 session javax.servlet.http.HttpSession 상태정보 유지 객체 application javax.servlet.ServletContext 상태정보 유지 객체 config javax.servlet.ServletConfig 서블릿 정보 추출 객체 out javax.servlet.jsp.JspWriter 출력 처리 객체 pageContext javax.servlet.jsp.PageContext JSP 페이지 처리 객체[2] ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:3","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"EL (Expression Language) JSP 2.0 spec에 추가된 기능이며, EL 사용시 Bean의 프로퍼티에 Action 태그를 사용하는것보다 쉽게 접근할 수 있으며 코드 간소화의 이점을 가진다. request, session, application의 정보를 추출하거나 태그 지정 등에 사용될 수 있다. // request 정보 추출 request.setAttribute(\"book\", book); ... ${book.title} // 태그 내에 값 지정 \u003cjsp:forward page=\"${info}\"\u003e ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:4","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"JSTL (JSP Standard Tag Library) JSTL은 자주 사용될 수 있는 커스텀 태그들을 모아둔 태그 라이브러리다. 사용하고자 하는 접두어를 \u003c%@ taglib uri = \"uri\" prefix = \"prefixOfTag\" %\u003e를 통해 추가하여 사용할 수 있다. 이름 접두어 기능 코어 c 변수, 제어문, 페이지 처리 함수 fn collection 및 String 처리 포맷 fmt 포맷 처리 및 국제화 DB sql DB CRUD 처리 xml x xml 관련 처리 ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:3:5","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"Related Posts 자바 고양이 Tomcat Servlet 정의 ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:4:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"footnote [1] property 속성에 와일드카드(*)를 지정가능하다. 와일드카드가 지정되면 Bean의 모든 setter 메서드를 호출하고 이름이 일치하는 쿼리스트링의 값들을 일괄 바인딩시킨다. [2] PageContext객체는 JSP 파일당 하나씩 자동으로 생성되는 객체이다. ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:5:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"References heejeong Kwon님의 블로그 - [Web] JSP란 “Servlet \u0026 JSP 웹 프로그래밍”(오정임 저, 루비페이퍼) ","date":"2021-02-28","objectID":"/posts/2021-02-28-jsp/:6:0","tags":["JSP"],"title":"JSP (Java Server Pages) 정의","uri":"/posts/2021-02-28-jsp/"},{"categories":["Programming"],"content":"Web Server와 WAS 정의 Tomcat을 논하기 앞서, 웹 서버(Web Server)와 웹 애플리케이션 서버(Web Application Server)의 차이를 짚고 넘어가고자 한다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:1:0","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Web Server 소프트웨어 측면에서의 정의는 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠를 제공하는 서버이다.[1] 웹 서버는 요청에 따라 아래의 두 가지중 하나로 기능한다. 정적인 컨텐츠 제공 WAS 거치지 않고 바로 정적 자원 제공 동적인 컨텐츠 제공을 위한 요청 전달 클라이언트의 요청을 WAS에게 전송, WAS가 처리한 결과를 클라이언트에게 응답 대표적인 Web Server는 Apache (httpd), nginx, IIS가 있다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:1:1","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"WAS WAS는 DB조회나 내부 로직을 통한 동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버이자 미들웨어이다. WAS는 Web Server 기능에 Web Container(또는 Servlet Container)[2] 기능이 추가된 것이다. WAS의 사용 목적 Web Server만 존재한다면 동적인 컨텐츠는 제공해줄 수 없기에 사용자가 원하는 결과에 대한 컨텐츠들을 미리 만들어두어야 하는데, 이럴 경우 서버의 리소스가 부족하게 될 수 있다. WAS를 이용하면 모든 결과를 미리 만들어놓지 않아도 요청시 원하는 결과를 동적으로 만들고 제공하여 리소스를 효율적으로 사용할 수 있다. WAS와 Web Server의 구분 이유? WAS와 Web Server를 분리하면 다음과 같은 이점을 얻을 수 있다. 여기서 말하는 Web Server는 WAS 자체 Web Server 기능이 아닌 WAS 외부의 Web Server를 말한다. 기능의 분리를 통한 부하 방지[3] HTML이 클라이언트로 전송된 후, 클라이언트는 HTML내에 포함되어야하는 이미지와 같은 정적 파일들을 서버로 요청한다. Web Server를 이용하면 WAS까지 가지 않고도 정적 파일들을 앞단에서 서빙해줄 수 있다. 즉, 정적인 컨텐츠는 Web Server에서, DB조회나 로직 처리를 통한 동적 컨텐츠는 WAS에서 제공하도록 하여 WAS의 부하를 낮춘다. 물리적으로 분리하여 보안 강화 Web Server를 통해 여러대의 WAS 연결 로드 밸런싱 가능 무중단 배포 및 운영 가능 정리하자면 장애 극복(fail over), 배포 및 유지보수의 편의성등을 위해 WAS와 Web Server를 분리한다. 대표적인 WAS는 Tomcat, Jeus, JBoss 등이 있다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:1:2","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Tomcat이란? Tomcat은 일반 상용 WAS 제품처럼 Java EE의 스펙을 모두 갖추지 않고 JSP와 Servlet을 실행하는 컨테이너와 Web Server만을 제공하는 WAS이자 거대한 자바 애플리케이션이다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:2:0","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Tomcat Architecture Tomcat Architecture\"\rTomcat Architecture\r Tomcat 구성요소 Tomcat 내부에서 Catalina, Coyote, Jasper는 핵심 역할을 담당하는 요소이다. Tomcat 5계층 구조를 정리하기 앞서 우선적으로 핵심요소 및 기타요소들을 나열하고 넘어간다. name description Catalina Servlet Container의 구현체이며 Engine이다. 서블릿 컨테이너는 클라이언트로 받은 요청들을 처리하고, 요청들에 기반한 응답을 반환하는 주체다. 또한, 서블릿 컨테이너는 서블릿들을 가지며, 서블릿 라이프사이클을 통해 서블릿들을 관리하고 제어한다. Coyote 웹 브라우저와 서버간의 HTTP 통신을 담당하는 디폴트 커넥터이다. Jasper 톰캣의 JSP 엔진이며 JSP 파일을 해석하여 서블릿 코드로 컴파일하며, JSP 파일의 변경을 감지하여 리컴파일 작업도 수행한다. Valve Engine, Host, Context와 관련된 각각의 요청 처리 파이프라인 상에서 전처리를 수행하기 위해 추가될 수 있는 컴포넌트다. Servlet Filter와 유사하나 Filter는 웹 애플리케이션 레벨에서 동작하나 Valva는 컨테이너 레벨에서 동작한다. Realm Engine에 위치한 Realm은 사용자 인증과 인가를 담당한다. Realm은 3가지로 분류된다. JDBCRealmJNDIRealmMemoryRealm Logger Logger는 컴포넌트 내부 상태를 리포트한다. 하위 컴포넌트의 Logger 특성은 상위 컴포넌트의 Logger 특성을 상속받으며 재정의(override)될 수 있다. Tomcat의 5계층 구성 tier name description 1 Server 1개의 JVM당 1개의 Server(톰캣 인스턴스)를 갖으며 Server는 Service들의 Life Cycle관리를 담당한다. 1개의 Server에는 여러개의 Service가 존재할 수 있다. 2 Service 1개의 Service는 1개의 Engine과 여러개의 Connector를 갖는다. 3 Engine Engine(Catalina)은 Connector에서 수신받은 요청을 하위 Host에게 전달해주는 역할을 수행한다. 4 Host 1개의 Host에는 여러개의 Context가 존재할 수 있다. Host 이름은 URL에 매핑된다. 5 Context Context는 Host 내에서 실행되는 개별 웹 애플리케이션을 나타내는 구성요소이며 주로 war 파일의 형태로 webapps 디렉토리 내에 배포된다. 5계층 중에서 개발자가 직접적으로 건드리는 부분은 Context이며, /conf/server.xml파일을 살펴보면 핵심 컴포넌트에 대응되는 태그들이 5계층 구조에 맞게끔 중첩되어있는 것을 확인할 수 있다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:2:1","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Tomcat Connector 외부 클라이언트로부터 요청을 받고 응답을 주는 인터페이스이며 TCP 포트에서 요청을 LISTEN 하여 Engine으로 보내주는 역할을 수행한다. 톰캣에는 총 3종류의 Connector가 존재한다. name description HTTP/1.1 [4] HTTP/1.1 프로토콜을 지원하는 커텍터다. 기본적으로 NIO와 APR간 자동 스위칭되며, 명시적으로 지정할 경우 NIO, NIO2, APR를 택할 수 있다. incoming되는 각각의 요청은 스레드가 필요하다. HTTP/2 [5] HTTP/2 프로토콜을 지원하는 커넥터다. Non blocking I/O를 사용하며 스레드 풀의 컨테이너 스레드를 사용한다. AJP [6] Web Server의 요청을 처리하기 위해 AJP 프로토콜을 사용한다. Apache가 웹 애플리케이션에 포함된 정적 컨텐츠를 처리하게 하거나 Apache의 SSL 처리를 활용하려는 경우에 사용된다. 기본적으로 NIO와 APR간 자동 스위칭되며, 명시적으로 지정할 경우 NIO, NIO2, APR를 택할 수 있다. Connector마다 동작하는 방식을 설정 가능하며 4종류가 존재한다. BIO : Tomcat 7의 기본방식, 1개의 Thread가 1개의 Connection을 담당 (기본 값: maxConnections = maxThreads = 200) NIO : Tomcat 8.5 부터의 기본방식, 1개의 Thread가 1개 이상의 Connection을 담당 (기본 값: maxConnections = 10000, maxThreads = 200) NIO2: 자바 7부터 지원되며 NIO에서 네트워크 자원을 대폭 강화시켰다.[7] APR : Apache Portable Protocol [8] (기본 값: maxConnections = 8192) server.xml에서 Connector를 정할 수 있으며 정한 Connector에 따른 동작방식을 설정가능하다. 설정 한 이후에는 아래 4개의 값을 필수적으로 고려해야한다. maxThreads : Connector가 생성가능한 최대 Thread 수 (Active User수 의미) maxConnections : 동시 처리 가능한 최대 Connection 수 maxSpareThreads : 최소로 실행을 유지할 Thread 수 (default = 10) acceptCount : 모든 Thread 사용 시 큐에 저장 가능한 최대 Request 수 (default = 100) Thread Pool은 Dedicated Thread Pool과 Shared Thread Pool로 종류가 나뉜다. Dedicated Thread Pool [9] : Connector마다 별개의 Thread Pool을 가지는 것이다. sever.xml에서 \u003cConnector\u003e태그에 지정된 관련 설정들이 Dedicated Thread Pool에 적용된다. Shared Thread Pool : Engine에 적용된 여러개의 Connector가 공유하여 사용하는 Thread Pool이다. sever.xml에서 \u003cExecutor\u003e태그를 정의하고 \u003cConnector\u003e태그에 등록하면된다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:2:2","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Tomcat 디렉토리 구조 Tomcat ├── bin ├── conf ├── lib ├── logs ├── webapps │ ├── docs │ ├── host-manager │ ├── manager │ └── ROOT │ └── work 디렉토리 설명 /bin 톰캣을 구동하기위한 바이너리와 시작 및 중단 스크립트를 포함한다. startup : 톰캣 기동shutdown : 톰캣 중단 /conf webapps에 적용하는 전역 설정 server.xml : 주 설정 파일 (서버 접근과 접속에 관한 설정)web.xml : 디폴트 서블릿 지정 및 서블릿 매핑 (톰캣 구동시 가장 먼저 읽는 파일)context.xml : WEB-INF/web.xml을 읽도록 설정되어 있음 /lib 톰캣에서 사용하는 jar 라이브러리 디렉토리이다. Servlet API와 JSP API가 위치하며 톰캣에 배치되는 모든 웹 애플리케이션은 해당 디렉토리에 저장된 라이브러리를 액세스 할 수 있다. /logs 로그 디렉토리 /temp 톰캣이 실행되는 동안 임시파일들이 위치하는 디렉토리 /webapps 웹 애플리케이션을 배포하는 기본 디렉토리이다. war파일을 webapps디텍토리 안에 위치시키면 하나의 Context로서 배포된다. webapps └── web application (web root) ├── WEB-INF │ ├── classes │ ├── lib │ └── web.xml │ ├── META-INF │ └── web.xml │ └── html \u0026 jsp /WEB-INF 디렉터리는 클라이언트가 직접적으로 접근할 수 없다.classes : 컴파일된 서블릿 클래스(.class)들이 위치한 서블릿 디렉터리다.lib : jar 라이브러리들이 위치한다. /work 컴파일된 파일 ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:3:0","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Tomcat 설정파일 주 설정 파일 /conf/server.xml은 톰캣의 주설정 파일이며 접근과 접속에 관한 설정이 주를 이룬다. 기타 설정 파일 web.xml파일은 URI 요청시 어떤식으로 반응할지에 대한 설정이 주를 이룬다. 이 파일은 톰캣 내에 2개가 존재한다. $CATALINA_HOME/conf/web.xml : 전역 설정 파일 (default) ContextRoot/WEB-INF/web.xml : 지역 설정 파일 conf/web.xml에 정의된 내용들이 디폴트로 적용되고 WEB-INF/web.xml에 정의된 내용들은 디폴트로 적용된 내용들에서 재정의(override)되어 적용된다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:3:1","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"footnote [1] 웹 서버에 대한 하드웨어 측면에서의 정의는 소프트웨어와 웹사이트의 컴포넌트 파일(html, css, …)들을 저장하는 컴퓨터이다. [2] 웹 컨테이너는 JSP와 Servlet 실행 환경을 제공한다. [3] Tomcat 5.5 버전부터 기능의 분리를 굳이 하지 않아도 성능면에서 크게 문제될 것이 없다. (톰캣 5.5 이상에서는 httpd의 native 모듈로 static page 처리) 오히려 정적 컨텐츠 처리를 위한 Web Server를 WAS의 앞단에 두는 것이 오버헤드가 될 수 있다. 토비님의 경우 Web Server를 앞단에 두는 것은 로드 밸런싱이 필요하거나 여러대의 WAS를 연결시키기 위함이라고 한다. [4] 톰캣 공식문서 - HTTP/1.1 [5] 톰캣 공식문서 - HTTP/2 [6] 톰캣 공식문서 - AJP [7] NIO2에 대한 설명 [8] Tomcat 10.x대 버전부터는 삭제, 참조 링크 [9] 실제 운영환경에서는 Dedicated Thread Pool을 주로 사용한다고 한다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:4:0","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"References https://cassandra.tistory.com/4 hyunjae-lee님의 블로그 - Tomcat(2) 구조 gnujava.com - Apache Tomcat 개요 Web Server와 WAS의 차이와 웹 서비스 구조 Apache Tomcat 연동하기 - 1. 연동하는 이유 “자바 고양이 Tomcat 이야기”(최진식 저, 좋은땅) ","date":"2021-02-23","objectID":"/posts/2021-02-23-tomcat/:5:0","tags":["Tomcat","Servlet"],"title":"자바 고양이 Tomcat","uri":"/posts/2021-02-23-tomcat/"},{"categories":["Programming"],"content":"Servlet이란? 클라이언트의 요청을 처리하고 결과를 반환하는, Servlet 클래스의 구현 규칙을 지킨 웹 프로그래밍 표준 기술을 말한다. 모든 서블릿은 javax.servlet.http.HttpServlet 클래스나 javax.servlet.GenericServlet을 상속받아서 구현되어야 하며, 서블릿 객체들은 서블릿 컨테이너에 의해 관리되고 제어되어진다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:1:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Servlet의 동작 Servlet LifeCycle\"\rServlet LifeCycle\r ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:2:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"HTTP 요청에따른 실행 순서 HTTP 요청을 커넥터(Coyote)에서 받고 서블릿 컨테이너(Catalina)로 전달한다. 서블릿 컨테이너는 전달받은 HTTP 요청을 처리할 웹 애플리케이션(Context)을 찾고, 웹 애플리케이션에 대응되는 deployment descriptor file(web.xml)의 내용을 참조하여 어떤 URL과 매핑되어 있는지 확인한다. 서블릿 컨테이너는 요청 URL을 통해 대응되는 서블릿을 실행한다. 서블릿 컨테이너는 현재 실행할 서블릿이 메모리에 있는지 확인하여 최초의 요청인지 판단한다. 서블릿이 메모리에 없다면 최초의 요청이므로, 서블릿 코드(.java)를 컴파일하여 바이트코드(.class)를 생성한다. 서블릿에 대한 메모리를 할당하고 서블릿 객체를 생성한다. 초기화 매개변수로 지정한 값들을 통해 ServletConfig객체를 생성한다. 서블릿 객체의 init 메서드를 호출하여 초기화 작업을 수행한다. 이 때, init 메서드에 대한 파라미터로 앞서 생성한 ServletConfig객체를 넘긴다. 서블릿 컨테이너는 HttpServletRequest와 HttpServletResponse 객체를 생성한다. 서블릿 컨테이너가 서블릿 객체의 service 메서드를 호출한다. service 메서드는 HTTP 요청의 METHOD에 대응되는 메서드를 호출한다. service메서드 수행 이후, 처리 결과를 클라이언트에게 응답한다. 이 때, HttpServletRequest와 HttpServletResponse 객체는 소멸한다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:2:1","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Servlet 인터페이스 서블릿 인터페이스는 5개의 메서드를 선언하고 있다. 5개중 핵심되는 메서드는 init, service, destroy다. name description init init은 서블릿 객체가 최초로 생성된 다음에 한 번만 호출되는 메서드이다. 메서드 호출 시 서블릿 컨테이너가 초기화 매개변수를 서블릿에게 전달한다. 역할: 서블릿 객체의 초기화 작업을 담당. service 클라이언트의 요청이 있을 때마다 서블릿 컨테이너에 의해 매번 실행된다. service 메서드는 HTTP 요청의 METHOD(GET, POST, PUT, DELETE, …)에 따라 대응되는 메서드(doGet, doPost, doPut, doDelete)를 호출한다. 필요에따라 service 메서드를 오버라이드 하거나 doGet, doPost 메서드 등을 오버라이드하여 작성토록한다. 역할: 요청에따른 실제 처리해야할 작업 수행 destroy 서블릿 객체가 메모리에서 삭제될 때 실행된다. (서비스나 서버 중지 시)역할: 자원해제 작업 수행 getServletConfig 하나의 서블릿 초기화에 필요한 정보를 담은 ServletConfig 객체를 반환한다. getServletInfo 작성자, 버전 및 저작권과 같은 서블릿에 대한 기본 정보를 담은 String을 반환한다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:2:2","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Servlet 동시성 서블릿 객체는 싱글턴 객체이며 멀티 스레드 환경에서 동작함을 유념한다.(싱글턴 사용시 주의사항 참고) Servlet Concurrency\"\rServlet Concurrency\r 즉, 여러 스레드가 서블릿 객체를 공유하여 사용하므로 필히 병행성 제어(Concurrency Control) 처리를 해주어야 한다. 정적 변수, 멤버 변수: 공유하는 자원이므로 Thread-safe하지 않다. 상호배제가 필요하다. 지역 변수: 스레드마다 독립적으로 생성되므로 Thread-safe하다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:2:3","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Servlet의 구현 ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:3:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Servlet URL 매핑 URL에 따른 서블릿 객체 매핑 방법은 두가지가 존재한다. 1. Web Deployment Descriptor 파일을 사용하는 방법\r Servlet API 3.0 미만에서는 서블릿을 매핑할 때 Web Deployment Descriptor(web.xml) 파일을 사용하여 매핑하여야 한다. \u003c!-- 서블릿 클래스 정의 --\u003e \u003cservlet\u003e \u003cservlet-name\u003eact\u003c/servlet-name\u003e \u003cservlet-class\u003eaction.ActionServlet\u003c/servlet-class\u003e \u003c!-- 초기화 매개변수 지정 --\u003e \u003cinit-param\u003e \u003cparam-name\u003ealpha\u003c/param-name\u003e \u003cparam-value\u003etest\u003c/param-value\u003e \u003c/init-param\u003e \u003cinit-param\u003e \u003cparam-name\u003ebeta\u003c/param-name\u003e \u003cparam-value\u003ecase\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003c!-- 서블릿 클래스와 URL간 매핑 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eact\u003c/servlet-name\u003e \u003curl-pattern\u003e/test.do\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 2. 애노테이션을 사용하는 방법\r Servlet API 3.0 spec부터는 javax.servlet.annotation이라는 패키지를 추가하였다.[1] 애노테이션을 통해 Web Deployment Descriptor 파일(web.xml)의 XML 설정을 대체가능하다. 서블릿 매핑과 관련된 애노테이션 타입은 아래와 같다. @WebServlet : 서블릿 매핑 URL 지정 @WebInitParam : 초기화 매개변수 지정 @WebServlet(value = \"/test.do\", initParams = {@WebInitParam(name=\"alpha\", value=\"test\"), @WebInitParam(name=\"beta\", value=\"case\")}) public class Simple extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response throws ServletException, IOException { ... } } ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:3:1","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"Related Posts 자바 고양이 Tomcat JSP (Java Server Pages) 정의 ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:4:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"footnote [1] Tomcat 7 이상 부터 사용가능하다. ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:5:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Programming"],"content":"References heejeong Kwon님의 블로그 - [Web] Servlet이란 nesoy님의 블로그 - Java Servlet에 대해 “Servlet \u0026 JSP 웹 프로그래밍”(오정임 저, 루비페이퍼) ","date":"2021-02-23","objectID":"/posts/2021-02-23-servlet/:6:0","tags":["Servlet"],"title":"Servlet 정의","uri":"/posts/2021-02-23-servlet/"},{"categories":["Setting"],"content":"인코딩 설정 관련 ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:1:0","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Setting"],"content":"이클립스 IDE에서의 인코딩 이클립스에서 설정해주는 인코딩 타입은 아래의 경우에서 사용된다. 파일의 저장 형식 저장된 파일을 읽어서 보여줄 때 사용 여러 사람이 협업하는 상황에서 서로간의 인코딩 설정값이 다르면, 한글같은 2byte 길이의 국가 언어 코드가 깨져보일 수 있다. 이클립스 인코딩 설정\"\r이클립스 인코딩 설정\r window → Preferences에 들어가서 “encoding” 검색 General → Workspace에 들어가서 “Text file encoding” 설정에서 타입을 UTF-8로 변경 ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:1:1","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Setting"],"content":"JSP의 인코딩 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e JSP 파일은 파일 내의 코드에서 자신을 어떤 인코딩 타입으로 저장할지 정한다. 이클립스 환경설정에서 JSP 파일의 인코딩 타입을 설정하면 이후부터 JSP 파일을 생성할 때 인코딩과 관련한 코드를 설정한 타입으로 하여 생성한다. JSP 파일 인코딩 설정\"\rJSP 파일 인코딩 설정\r window → Preferences에 들어가서 “encoding” 검색 Web → JSP Files에 들어가서 “Encoding” 설정에서 타입을 UTF-8로 변경 JSP 파일 인코딩 설정과 별도로 CSS, HTML파일 또한 위와 같은 방법으로 설정해준다. pageEncoding (JSP 파일 저장관련) pageEncoding 타입은 어떠한 타입으로 인코딩해서 저장할지, 어떠한 타입으로 디코딩해서 출력할지를 저장해주는 설정이다. pageEncoding 설정이 누락되었다면 JSP 파일에서 서블릿 파일로 변환될때 한글문자가 깨지게됨을 유의한다. contentType (클라이언트 전송 관련) JSP 파일이 서블릿 파일로 변환되고, 서블릿 파일이 클라이언트(브라우저)에게 html을 전송해줄 것이다. 전송해줄 때, html 내부의 문자열들을 인코딩하는 타입을 지정해주는 부분이 contentType이다. contentType에 설정된 타입으로 인코딩하여 데이터를 전송하면서 http 헤더에 contentType을 명시해주는데 브라우저는 헤더의 contentType에 설정된 타입으로 디코딩하여 브라우저에 출력한다. contentType에 인코딩 타입이 지정되어있으면 \u003chtml\u003e태그 내의 \u003cmeta\u003e태그에 지정된 인코딩 타입은 무시된다. 위의 방법 대신 자바 코드 상에서 contentType을 설정해주고자 한다면, HttpServletResponse 객체를 반환하는 부분에서 setContentType메서드를 사용하면 된다. setContentType메서드를 통한 설정은 응답 객체에 대한 출력 스트림을 열기전에 적용되어야함을 유념한다. //contentType 설정 response.setContentType(\"text/html;charset=UTF-8\"); //응답에 대한 출력 스트림 response.getWriter() .print(\"\u003ch2\u003e테스트\u003c/h2\u003e\"); .close(); 인코딩 설정 순위 target description IDE/ Tomcat pageEncodingcontentType의 charset 참조 (pageEncoding이 없는 경우)시스템 디폴트 설정 참조 (charset 없는 경우) 브라우저 contentType의 charset\u003chtml\u003e태그 내의 \u003cmeta\u003e태그 참조 (contentType의 charset이 없는 경우)브라우저 디폴트 설정 참조 (\u003cmeta\u003e태그 없는 경우) ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:1:2","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Setting"],"content":"서블릿의 인코딩 POST request에 대한 인코딩 타입 클라이언트에서 POST로 데이터를 request하는 경우 아래의 순으로 실행된다. 클라이언트에서 서버로 데이터를 보내는 경우에는 contentType에 지정했던 타입으로 인코딩하여 전송한다. WAS에서는 받은 데이터를 시스템 디폴트 인코딩 타입으로 디코딩하여 request 객체를 생성한다.[1] 디폴트 인코딩 타입이 UTF-8로 되어있지않다면 디코딩 시 한글이 깨지므로 서블릿 코드 상에서 별도의 처리를 진행해야한다. 아래의 코드를 서블릿의 HttpServletRequest 객체를 받아오는 메서드내에 포함하면되나 DRY 원칙을 위배하므로 필터에 적용해주도록한다. request.setCharacterEncoding(\"UTF-8\"); GET request에 대한 인코딩 타입 클라이언트에서 GET으로 데이터를 넘기는 경우 요청 데이터가 URL뒤에 붙어 전송된다. URI 디폴트 인코딩 방식이 UTF-8로 구성되어있지 않은 경우 한글이 깨지는데 아래의 방법으로 인코딩을 설정할 수 있다. 1. request.setCharacterEncoding 메서드를 사용하도록 설정\r server.xml 파일의 \u003cConnector\u003e태그(현재 사용하고 있는 포트가 지정된 태그) 내에 useBodyEncodingForURI를 true로 설정한다. 이렇게 설정하면 POST 객체 처럼 다룰 수 있다. \u003cConnector useBodyEncodingForURI=\"true\" connectionTimeout=\"20000\" port=\"80\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" /\u003e 2. URI 인코딩 타입을 고정\r server.xml 파일의 \u003cConnector\u003e태그(현재 사용하고 있는 포트가 지정된 태그) 내에 URIEncoding을 UTF-8로 설정한다. 이렇게 설정하면 모든 URI에 대한 인코딩을 설정한 타입으로 강제하게 된다. \u003cConnector URIEncoding=\"UTF-8\" port=\"80\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" /\u003e ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:1:3","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Setting"],"content":"footnote [1] 디폴트 인코딩 타입은 WAS의 버전마다 다르다. ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:2:0","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Setting"],"content":"References https://codevang.tistory.com/196 ","date":"2021-02-22","objectID":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/:3:0","tags":["Eclipse","JSP","Servlet"],"title":"Eclipse, JSP, Servlet 인코딩","uri":"/posts/2021-02-22-eclipse-jsp-servlet-encoding/"},{"categories":["Programming"],"content":"자바8 이전의 날짜 클래스 자바8 이전에 사용하던 java.util.Date와 java.util.Calendar 등은 많은 문제점이 존재하였다. 대표적인 문제점을 추리면 다음과 같다. 불변성(Immutable)을 보장하지 않는다. 불변성을 보장하지 않기에 Thread-safe하지 않다. Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.Month, 2 - 1); Date date = new Date(); date.setTime(new Date()); 클래스 이름이 Date인데 시간까지 다룬다. int 상수 필드의 남용 Date와 Calendar의 불편한 역할 분담 Month 계산이 혼동스럽다. (1월을 나타내는 상수 값이 0부터 시작한다) // 1월이 아닌 2월이 된다. calendar.set(Calendar.Month, 1); // 1월을 표시하기 위해서는 상수 값 0이나 // Calendar에서 제공하는 static 필드를 사용해야 한다. calendar.set(Calendar.Month, Canlendar.JANUARY); java.util.Date 하위 클래스의 문제 java.util.Date를 상속한 클래스는 java.sql.Date와 java.sql.Timestamp가 있다. java.sql.Date의 경우 Comparable 인터페이스에 대한 정의를 클래스 선언에서 하지 않아 Comparable과 관련한 선언들을 복잡하게 만들었으며, java.sql.Timestamp는 equals() 선언의 대칭성을 위반하였다.[1] 위에 언급된 대표적인 문제점 말고도 많은 문제점들이 존재한다. 자바 8부터는 개선된 날짜 및 시간 관련 클래스들을 제공하니 시간처리와 관련된 기능들을 다룰 때 가능하면 최대한 자바 8의 날짜 및 시간 관련 클래스들을 활용하자. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:1:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"자바8의 Date-Time API 자바 8에서는 java.time패키지에 LocalDateTime과 ZonedDateTime등을 추가하여 이전보다 향상된 날짜와 시간계산 기능을 가능하게 하였다. JSR-310 스펙으로 구현된 Date Time API는 아래의 디자인 철학을 가진다. Clear Fluent Immutable Extensible ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"인류용 시간(human time) |------------------------ZonedDateTime------------------------| |---------------OffsetDateTime---------------| |--------LocalDateTime--------| |--LocalDate--|---LocalTime---|--ZoneOffset--|---ZoneRegion---| 2021-02-18 13:00:00 +09:00 Asia/Seoul 인류용 시간은 연, 월, 일, 시, 분, 초 등을 표현하며 인간이 쉽게 사용하고 읽을 수 있는 시간 형식을 말한다. LocalDateTime, LocalDate, LocalTime은 서버 배포시 서버가 실행되는 국가에 따라 시간이 자동 세팅되므로 유의해야한다. 따라서 국내에서 서비스 한다면 LocalDateTime으로 처리하고, 글로벌 서비스까지 한다면 timezone이 추가된 ZonedDateTime 사용을 고려해야 한다. human time 관련 클래스 name description LocalDate, LocalTime, LocalDateTime 시간대 정보(Zone Offset, Zone Region)가 포함되지 않은 클래스이다. LocalDate: 특정 날짜LocalTime: 특정 시간LocalDateTime: 일시 ZoneOffset UTC 기준으로 시간(Time Offset)을 나타낸 것이다.ZoneOffset은 ZoneId를 상속한다. ZoneRegion Time Zone을 나타낸 것이다. 예시로 한국의 경우 KST는 타임존의 이름이며 이에 대응되는 ZoneRegion은 Asia/Seoul이다. ZoneRegion은 ZoneId를 상속하나 public 클래스가 아니므로 ZoneId를 통해서만 생성 가능하다. OffsetDateTime LocalDateTime에 ZoneOffSet의 정보까지 붙은 클래스이다. ZonedDateTime OffsetDateTime에 ZoneRegion의 정보까지 붙은 클래스이다. ZoneOffset과 ZoneRegion을 보면 차이가 없어보인다. 하지만, API를 설계할 때 아무 이유없이 차이도 없는 클래스를 두개나 정의하지 않았을 것이다. 둘의 차이는 Time Transition Rule[2]을 포함하는지 포함하지 않는지에 따라 다르다. ZoneOffset: Time Transition Rule을 포함하지 않는 ZoneRules를 가진다. ZoneRegion: Time Transition Rule을 포함할 수도 있고 포함하지 않을 수도 있다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:1","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"기계용 시간(machine time) 기계용 시간이란 UTC 기준으로 EPOCH (1970년 1월 1일 0시 0분 0초)부터 현재에 이르기까지의 타임스탬프를 말한다. 즉, 인간이 읽고 쓰기에는 적합하지 않으나 기계에서 사용하기에는 적합한 시간을 의미한다. 많은 개발자들이 Long 타입 UNIX Timestamp를 사용한다. 타임스탬프 사용 이유로는 정수형을 이용한 정렬 및 기타 연산등에서 다른 타입보다 빠른 연산속도를 가지기 때문이다. 하지만, UNIX Timestamp의 경우 Year 2038 problem을 가지고 있기에 자바8에서는 Timestamp의 문제를 해결하기 위해 Instant 클래스를 추가하였다. Instant 사용예시 현재 시간의 타임스탬프 값 구하기 Instant current = Instant.now(); long epochSecond = current.getEpochSecond(); long epochMilli = current.toEpochMilli(); Instant to ZonedDateTime/ ZonedDateTime to Instant // Instant to ZonedDateTime Instant instant = Instant.now(); ZonedDateTime krTime = instant.atZone(ZoneId.of(\"Asia/Seoul\")); // ZonedDateTime to Instant ZonedDateTime krTime = ZonedDateTime.of(2020, 8, 18, 6, 57, 38, ZoneId.of(\"Asia/Seoul\")); Instant instant = krTime.toInstant(); Instant to LocaldDateTime/ LocalDateTime to Instant // Instant to LocalDateTime Instant instant = Instant.now(); LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC); // LocalDateTime to Instant LocalDateTime localDateTime = LocalDateTime.of(2020, 8, 18, 6, 57, 38); Instant instant = localDateTime.toInstant(ZoneOffset.UTC); 기타 유용한 메서드들 Instant는 초 또는 밀리초 단위로 시간을 더하거나 빼는 메서드 및 비교하는 메서드 등을 제공 Instant instant = Instant.now(); instant.plusSeconds(10); instant.minusSeconds(10); instant.isBefore(Instant.now()); instant.isAfter(Instant.now()); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:2","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"기간의 표현 자바8에서 추가된 time 패키지 내에는 기간을 표현하기 위한 Duration과 Period가 존재한다. Duration (시간 기반) Duration은 두 시간 사이의 간격을 초나 나노초 단위로 나타내기 위해 사용한다. Duration 사용예시 LocalTime startTime = LocalTime.of(11, 23, 40); LocalTime endTime = LocalTime.of(11, 24, 50, 800); Duration duration = Duration.between(startTime, endTime); long sec = d.getSeconds(); long nano = d.getNano(); Period (날짜 기반) Period는 두 날짜 사이의간격을 년, 월, 일 단위로 나타내기 위해 사용한다. Period 사용예시 LocalDate startDate = LocalDate.of(2014, 3, 1); LocalDate endDate = LocalDate.of(2015, 4, 5); Period p = Period.between(startDate, endDate); int year = p.getYears(); int month = p.getMonths(); int day = p.getDays(); ChronoUnit ChronoUnit을 사용하면 Duration 또는 Period 객체 생성 없이 날짜 및 시간의 간격을 표현할 수 있다. ChronoUnit 사용예시 LocalTime startTime = LocalTime.of(11, 23, 40); LocalTime endTime = LocalTime.of(11, 24, 50, 800); long hours = ChronoUnit.HOURS.between(startTime, endTime); long minutes = ChronoUnit.MINUTES.between(startTime, endTime); long seconds = ChronoUnit.SECONDS.between(startTime, endTime); LocalDate startDate = LocalDate.of(2014, 3, 1); LocalDate endDate = LocalDate.of(2015, 4, 5); long months = ChronoUnit.MONTHS.between(startDate, endDate); long weeks = ChronoUnit.WEEKS.between(startDate, endDate); long days = ChronoUnit.DAYS.between(startDate, endDate); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:3","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"JDBC에서의 컨버팅 및 Legacy에서 마이그레이션 자바8 이상의 버전이 되면서 자바8 이전에 사용되던 Date, Timestamp등은 레거시가 되었다. 자바의 시간관련 타입들을 적절하게 사용하기위해서 기록해둔다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"JDBC에서의 컨버팅 형태 JDBC에서는 Java와 DB 스키마 사이에서 타입 컨버팅을 아래에 따라 자동 변환 시킨다. JDBC Converting\"\rJDBC Converting\r ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:1","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"Legacy에서 마이그레이션시 권장 타입 Legacy Migration\"\rLegacy Migration\r ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:2","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"footnote [1] Date 타입과 TimeStamp 타입을 섞어 쓰면 a.equals(b)가 true라도 b.equals(a)는 false인 경우가 생길 수 있다. [2] Time Transition Rule이란 일광 절약 시간제(DST, Daylight Saving Time)와 같이 표준시를 부분 조정하는 규칙을 말한다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:4:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"Related Posts ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:5:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"References https://www.daleseo.com/java8-duration-period/ https://madplay.github.io/post/java8-date-and-time https://perfectacle.github.io/2018/09/26/java8-date-time/ https://stackoverflow.com/questions/32437550/whats-the-difference-between-instant-and-localdatetime https://d2.naver.com/helloworld/645609 ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:6:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"스트림 특징 스트림 API는 컬렉션과 같이 연속된 데이터를 처리하는 용도로 사용한다. 저장하는 용도로 사용하는 것이 아니다. 스트림의 특징은 다음과 같다. for과 같은 외부반복자와 필터링을 위한 if등을 사용하지 않아 직관적이며 가독성이 좋아진다. //자바8 이전의 코드 List\u003cString\u003e list = Arrays.asList(\"a\", \"b\", \"c\"); Iterator\u003cString\u003e iterator = list.iterator(); while(iterator.hasNext()) { String item = iterator.next(); System.out.println(item); } //자바 8 이후 코드 List\u003cString\u003e list = Arrays.asList(\"a\", \"b\", \"c\"); Stream\u003cString\u003e stream = list.stream(); stream.forEach(item -\u003e System.out.println(item)); 최종 연산을 적용하면 스트림이 닫히고, 닫힌 스트림은 재사용이 불가능하다. 병렬(Parallel) 스트림을 사용가능하다. 병렬 스트림은 여러 스레드가 나누어 작업한다.[1][2] List\u003cString\u003e list = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"); Stream\u003cString\u003e parallelStream = list.parallelStream(); parallelStream.forEach(item -\u003e System.out.println(item)); 중개 연산은 미리하지 않으며 터미널 연산이 적용될 때 연산을 전체적으로 처리한다. (지연 연산) 정리하자면 스트림은 Iterator와 비슷하나, 스트림을 사용하면 코드를 간결하게 작성할 수 있을뿐더러 내부 반복자를 사용하므로 병렬처리가 쉽다는 장점이 존재한다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:1:0","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"스트림 사용법 스트림의 사용은 3단계로 나뉜다. (스트림 생성 → 중개 연산 → 최종 연산) ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:2:0","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"스트림 생성 배열 스트림 Arrays.stream 메서드를 사용하여 생성한다. String[] arr = new String[]{\"1\", \"2\", \"3\"} Stream\u003cString\u003e stream = Arrays.stream(arr); 컬렉션 스트림 컬렉션의 경우 인터페이스에 추가된 stream 메서드를 사용하여 생성한다. List\u003cString\u003e list = Arrays.asList(\"1\", \"2\", \"3\"); Stream\u003cString\u003e stream = list.stream(); 비어있는 스트림 Stream의 empty 메서드를 사용하여 빈 스트림을 생성할 수 있다. Stream\u003cString\u003e stream = Stream.\u003cString\u003eempty(); builder 메서드 사용 Stream의 builder 메서드를 사용하여 스트림을 직접적으로 생성할 수 있다. Stream\u003cString\u003e stream = Stream.\u003cString\u003ebuilder() .add(\"a\") .add(\"b\") .build(); generate 메서드 사용 Stream의 generate 메서드를 사용하여 Supplier 타입의 인자로 스트림을 생성 가능하다. 이 경우 생성되는 스트림의 크기가 정해져 있지 않기에 limit로 스트림 사이즈를 지정해야한다. Stream\u003cString\u003e stream = Steam.generate(() -\u003e \"st\") .limit(10); 기본 타입 스트림 Stream\u003cInteger\u003e와 같이 제네릭을 사용하여 스트림을 생성할 수 있으나 기본타입의 스트림을 생성하는 경우 오토박싱이 발생한다. 오토박싱을 발생안하게 하려면 제네릭 타입의 스트림 사용 대신 IntStream, LongStream, DoubleStream을 사용하여 기본형 스트림을 생성 가능하다. IntStream intStream = IntStream.range(1, 5); // [1, 2, 3, 4] LongStream longStream = LongStream.rangeClosed(1, 5); // [1, 2, 3, 4, 5] range: 두번째 인자 값 이전까지 스트림을 생성한다. rangeClosed: 두번째 인자 값까지 스트림을 생성한다. 문자열 스트림 문자열의 chars 메서드를 통해 IntStream을 생성할 수 있다. IntStream intStream = \"abcdefg\".chars(); 파일 스트림 Files 클래스의 lines 메서드를 통해 파일의 각 라인을 문자열 타입의 스트림으로 생성할 수 있다. Stream\u003cString\u003e fileStream = Files.lines(Paths.get(\"sample.txt\"), Charset.forName(\"UTF-8\")); 병렬 스트림 Stream\u003cString\u003e streamOfList = list.parallelStream(); // 병렬 스트림 생성 Stream\u003cString\u003e streamOfArray = Arrays.stream(arr).parallel(); // 배열을 통한 병렬 스트림 streamOfList.isParallel() // 병렬 스트림 여부 확인 streamOfList.sequential(); // 시퀀셜 모드로 돌리기 위해 사용 스트림 연결 Stream의 concat 메서드를 사용하여 스트림을 연결하여 새로운 스트림을 생성할 수 있다. IntStream stream1 = IntStream.range(1, 5); IntStream stream2 = IntStream.range(5, 10); IntStream concatedStream = IntStream.concat(stream1, stream2); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:2:1","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"중개 연산 중개 연산은 Stream객체를 리턴하기에 다양한 중개 메서드를 chaining하여 작성이 가능하다. 추가로, 중개 연산은 최종 연산이 적용되기 전까지 지연된다. 최종 연산이 적용될 때 중개 연산들을 일괄처리함으로써 미리 계산하면서 두 번 순회하는 불필요한 동작을 하지 않고 최종적으로 한번만 순회하며 데이터를 처리할 수 있다는 장점을 가진다. 중개 연산 종류 name description filter 스트림 내 요소들을 하나씩 조회하여 필터링하는 작업이다. 인자로 boolean 타입을 리턴하는 식이 들어가야 한다. distinct 요소 중복 제거 작업을 수행한다. map 스트림 내 요소들을 하나씩 특정 값으로 변환한다. flatMap 중첩 구조를 한 단계 제거하고 단일 컬렉션으로 만들어주는 역할을 수행한다.(flattening) 인자로 Stream 타입을 리턴하는 식을 넣어야한다. sorted 일반적인 정렬과 마찬가지로 Comparator을 인자로 사용한다. 만약 인자 없이 호출할 경우 기본적으로 오름차순으로 정렬한다. peek 단순히 스트림 내 요소들을 확인하기 위해 사용한다. 즉, 특정 결과를 반환하지 않는다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:2:2","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"최종 연산 스트림을 끝내는 터미널 단계이며, 가공한 스트림에 대한 결과를 반환한다. 최종 연산이 수행된 이후에는 스트림이 닫히게 되어 더 이상 사용할 수 없다. 최종 연산 종류 name description count 요소의 갯수를 계산한다. 스트림이 비어있는 경우 0이 반환된다. sum 요소의 합을 계산한다. 스트림이 비어있는 경우 0이 반환된다. min 요소 중 최솟값을 표현한다. 스트림이 비어있는 경우는 표현하지 못하므로 Optional 타입으로 반환된다. max 요소 중 최대값을 표현한다. 스트림이 비어있는 경우는 표현하지 못하므로 Optional 타입으로 반환된다. average 요소들의 평균값을 표현한다. 스트림이 비어있는 경우는 표현하지 못하므로 Optional 타입으로 반환된다. ifPresent 스트림에서 Optional을 처리하기 위해 사용한다. min, max, average와 연계된다. reduce 스트림 처리결과를 나타내기 위해 사용한다. reduce 메서드는 세 종류의 파라미터를 받을 수 있다. accumulator: 스트림의 각 요소가 들어올 때마다 중간 결과를 생성하는 식identity: 스트림 계산을 위한 초기값. 계산할 값이 없더라도 해당 값은 리턴된다.combiner: 병렬 스트림에서 나누어 계산한 결과를 하나로 합치는 식 collect Collector 타입의 인자를 받아서 처리한다. 주로 사용되는 작업은 Collectors 클래스에서 제공한다. anyMatch 하나라도 조건을 만족하는 요소가 있는지 검사한다. Predicate타입을 인자로 받는다. allMatch 모두 조건을 만족하는지 검사한다. Predicate타입을 인자로 받는다. noneMatch 모두 조건을 만족하지 않는지 검사한다. Predicate타입을 인자로 받는다. forEach 모든 요소를 순회하며 실행한다. peek와 유사하나 최종작업이다. Collectors에서 제공하는 작업 name description toList 스트림 작업 결과를 리스트로 반환한다. joining 스트림에서 작업한 결과를 문자열로 이어 붙인다. joining 메서드는 세 종류의 인자를 받을 수 있다. delimiter: 각 요소를 구분시켜주는 구분자prefix: 문자열 앞에 붙는 접두사suffix: 문자열 뒤에 붙는 접미사 averagingInt 평균값을 산출해낸다. summingInt 합을 산출해낸다. summarizingInt 평균값, 합 둘다 산출해낸다. IntSummaryStatistics타입의 객체를 리턴한다. groupingBy Function 타입의 인자를 받아 요소들을 그룹핑하는데 사용한다. partitioningBy Predicate 타입의 인자를 받아 true, false 기준으로 나눈다. collectingAndThen 결과를 collect한 이후 Collector타입을 반환하는 추가 작업을 수행하기 위해 사용한다. of Collectors에서 기본 제공하는 작업 이외의 작업이 필요한 경우 새로운 유형의 작업을 정의하기 위해 사용한다. 사용하는 인자는 reduce 메서드에서 사용하는 인자와 동일하다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:2:3","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"footnote [1] 애플리케이션에서 사용하는 스레드가 많거나 스트림을 위해 사용하는 컬렉션의 요소가 적다면 병렬 스트림을 사용하는데 오버헤드가 더 클 수 있다. [2] 자바에서는 병렬처리를 위해 ForkJoinPool 프레임워크를 사용한다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:3:0","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"Related Posts ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:4:0","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"References https://futurecreator.github.io/2018/08/26/java-8-streams/ ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-2nd/:5:0","tags":["Java","Stream"],"title":"[Java8의 변경사항] 2. 스트림(Stream) API","uri":"/posts/2021-02-18-java8-features-2nd/"},{"categories":["Programming"],"content":"Java8의 특징 자바 8은 2014년 3월에 출시된 LTS 버전이며 제공하는 주요기능은 다음과 같다. 람다 표현식: 함수형 프로그래밍 Stream API: 시퀀셜한 데이터의 추상화된 사용 java.time 패키지: 개선된 Date, Time API 제공 나즈혼(Nashorn): 자바스크립트의 새로운 엔진 도입 LTS(Long-Term-Support) 버전 LTS 버전 배포 주기는 3년이며 지원기간은 5년이상으로서 production환경에서는 LTS 버전을 권장한다. 비LTS 버전의 경우 배포 주기는 6개월이며 지원기간은 배포 이후 6개월로 제공기간이 짧다. ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:1:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"람다 표현식 (Lambda Expression) 람다 표현식이란 익명 클래스의 한개 메서드를 표현식으로 나타낸 것이다. 람다식의 장단점은 아래와 같다. 람다식 장점 코드가 간결해지고 가독성이 향상된다. 병렬 프로그래밍이 용이하다. 람다식 단점 디버깅이 복잡해진다. 람다식으로 작성된 함수는 재사용이 불가능하다. 정리하자면 람다 표현식 사용 시 작성된 코드의 가독성을 높일 수 있으나 무분별한 사용은 코드가 지저분해질 수 있을뿐더러 디버깅이 까다로워지니 적절히 사용해야할 것이다. 람다표현식 작성법 (매개변수 리스트) -\u003e {함수 몸체} 매개변수가 하나인 경우 ()를 생략가능하다. 매개변수의 타입은 생략 가능하나 명시할 수도 있다. (생략시 컴파일러가 타입 추론) 함수 몸체가 한 줄인 경우 {}와 return을 생략 가능하다. ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"함수형 인터페이스 (Functional interface) 람다 표현식을 사용하기 위해서는 우선, 함수형 인터페이스가 필요하다. 함수형 인터페이스란 단 한개의 추상 메서드만을 가지는 인터페이스를 말하며 @FunctionalInterface 어노테이션을 사용하여 함수형 인터페이스임을 명시할 수 있다. 아래의 코드는 함수형 인터페이스를 정의하고 이를 익명 클래스와 람다식으로 사용하는 예제이다. @FunctionalInterface public interface LambdaExample { //abstract void run(); abstract 생략 가능 void run(); } ... public class Program { public static void main(String[] args) { /* 익명 클래스로 사용 */ LambdaExample le1 = new LambdaExample() { @Override public void run() { System.out.println(\"run\"); } } le1.run(); /* 람다 표현식으로 사용 */ LambdaExample le2 = () -\u003e System.out.println(\"run\"); le2.run(); } } 함수형 인터페이스를 개발자가 직접 정의해서 사용할수도 있으나, 자바8에서 기본적으로 제공해주는 함수형 인터페이스들이 java.util.function에 존재한다. 기본 제공 함수형 인터페이스 name description Function\u003cT, V\u003e apply : T 타입을 받아서 V 타입을 리턴compose : 함수 조합, 파라미터로 들어온 함수가 우선 수행andThen : 함수 조합, 파라미터로 들어온 함수가 이후 수행 UnaryOperator\u003cT\u003e Function\u003cT, T\u003e를 extends apply : T 타입을 받아서 T 타입을 리턴 BiFunction\u003cT, U, V\u003e apply : T, U 타입을 받아서 V 타입을 리턴 BinaryOperator\u003cT\u003e BiFunction\u003cT, T, T\u003e를 extends apply : T 타입 두개를 받아서 T 타입을 리턴 Consumer\u003cT\u003e accept : T 타입을 받아서 동작 수행 (리턴 X)andThen : 함수조합 Predicate\u003cT\u003e test : T 타입을 받아서 boolean 리턴 and : 함수조합or : 함수조합negate : 함수조합 Supplier\u003cT\u003e get : T 타입의 값을 제공 ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:1","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"변수 캡쳐 (Variable Capture) 람다 표현식 함수 몸체에서 외부의 변수를 참조하는 것을 말한다. 참조된 변수의 앞에는 final을 붙여야 하나 자바8에서 부터는 생략 가능하다. (effective final: final이 붙지 않을 경우 동시성 문제가 발생할 수 있기에 컴파일러가 방지한다.) public void run() { int number = 100; //final 키워드 생략, number 변수는 람다식 내부에서 참조 IntConsumer consumer = (base) -\u003e System.out.println(base * number); consumer.accept(2); } 또한, 로컬 클래스와 익명 클래스에서는 쉐도잉이 발생하나 람다식에서는 쉐도잉이 발생하지 않는다. 즉 로컬 클래스와 익명 클래스의 scope와 이를 감싸고 있는 scope는 다르지만, 람다식의 경우 람다식을 감싸고 있는 scope와 동일하다. 변수의 쉐도잉 (Variable Shadowing) 쉐도잉이란 하위 scope와 상위 scope에서 각각 동일한 이름의 변수가 존재할 때, 하위 scope에서 해당 이름을 가진 변수를 사용하게 되면 상위 scope의 변수는 가려져 하위 scope의 변수가 사용되는 것을 말한다. public void run() { int number = 100; // 로컬 클래스 class LocalClass { void print() { int number = 1; System.out.println(number); // 1이 출력 } } // 익명 클래스 Runnable anonymousClass = new Runnable() { @Override public void run() { int number = 2; System.out.println(number); // 2가 출력 } }; // 람다식 Runnable lambdaExpression = () -\u003e { //int number = 3; // 불가능, 컴파일 에러 발생 System.out.println(number); // 100이 출력 }; } ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:2","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"메서드 레퍼런스 람다식을 직접 정의 할수도 있으나, 람다식이 단순히 특정 메서드나 생성자를 호출하는 것이라면 메서드 레퍼런스를 사용하여 간단히 표현할 수 있다. 메서드 레퍼런스 사용법 유형 형식 static 메서드 참조 타입::static 메서드 명 인스턴스 메서드 참조 참조 변수명::인스턴스 메서드 명 생성자 참조 타입::new 키워드 임의 객체의 메서드 참조 타입::인스턴스 메서드 명 이 중, 임의 객체의 메서드 참조는 인자로 전달되는 인스턴스를 특정하지 않는 경우에 사용한다. 즉 , 함수 객체를 적용하는 시점에 인자로 들어오는 인스턴스를 알려주며 주로 스트림 파이프라인에서 매핑과 필터 함수에 사용된다. 아래의 코드는 메서드 레퍼런스 사용 예시이다. public class Sample() { public Sample() { ... } public Sample(String arg) { ... } public static String concatStatic(String str) { return str + \"static\"; } public String concatInstance(String str) { return str + \"instance\"; } } ... public void run() { // 람다식 UnaryOperator\u003cString\u003e concat1 = string -\u003e string + \"someting\"; // static 메서드 레퍼런스 UnaryOperator\u003cString\u003e concat2 = string -\u003e Sample::concatStatic; // 인스턴스 레퍼런스 Sample sample1 = new Sample(); UnaryOperator\u003cString\u003e concat2 = string -\u003e sample1::concatInstance; // 기본 생성자 레퍼런스 Supplier\u003cSample\u003e sample2 = Sample::new; // 인자있는 생성자 레퍼런스 Function\u003cString, Sample\u003e sample3 = Sample::new; // 임의 객체의 메서드 참조 String[] list = {\"alpha\", \"beta\", \"gamma\"}; Arrays.sort(list, String::compareToIgnoreCase); } ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:3","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"Related Posts ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:3:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"References ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:4:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"JVM 정의 javac를 통해 생성된 Byte Code를 OS에 맞게 해석하여 실행시켜주는 역할을 수행한다. JVM은 크게 봤을 때 5개의 컴포넌트로 나뉜다. Class Loader Execution Engine Runtime Date Area JNI Native method library 이 5개의 컴포넌트 중 JNI와 Native method library를 제외한 3가지 컴포넌트에 대해 정리하고자 한다. Java Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce)\"\rJava Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce)\r ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:1:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"JVM 구성 요소 ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"클래스 로더(Class Loader) 클래스 로더는 JRE의 일부로서 런타임시 클래스들에 대한 정의를 런타임 데이터 영역에 동적 로드하는 역할을 수행한다. 클래스 로딩시에는 Thread-safe가 보장되고 한 번 로드된 클래스는 언로드 될 수 없다. 3가지 클래스 로더 Class Loader Hierarchy (출처: medium.com/@minfuyang)\"\rClass Loader Hierarchy (출처: medium.com/@minfuyang)\r Bootstrap class loader 네이티브 코드로 구현되어 있으며 3가지 기본 클래스 로더 중에서 최상위 클래스 로더이다. JVM이 실행되면 가장 우선적으로 부트스트랩 로더가 메모리상에 적재되며 이후 자바 클래스들을 로드할 수 있는 java.lang.ClassLoader를 포함하여 최상위 클래스(Object, String, …)들을 로딩한다. java8 : ${JAVA_HOME}/jre/lib/rt.jar내에 있는 모든 JDK 내부 클래스를 로드한다. java9 : rt.jar이 제거되고 /lib내에 모듈화되어 포함되었다. Extention class loader 기본 자바 API를 제외한 확장클래스들을 로드한다. java8 : URLClassLoader를 상속, jre/lib/ext내의 모든 클래스를 로드 java9 : URLClassLoader대신 BuiltinClassLoader를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, Platform Class Loader로 명칭 변경 Application class loader 사용자가 지정한 $CLASSPATH내의 모든 클래스들을 로드한다. 즉, 애플리케이션의 클래스들을 로드한다. java9 : URLClassLoader대신 BuiltinClassLoader를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, System Class Loader로 명칭 변경 User-Defined class loader 기본 클래스 로더가 아니다. 만약 3가지 클래스 로더가 사용하는 classpath외에 위치한 클래스를 로드시키고자 한다면 java.lang.ClassLoader 클래스를 상속하고 findClass메서드를 오버라이드한 커스텀 클래스 로더를 만들면된다. 3가지 원칙 클래스로더가 지켜야하는 3가지 원칙은 java.lang.ClassLoader의 loadClass메서드에 코드로 구현되어 있다. 위임 (Delegation) 클래스 로딩이 필요할 때 하위 클래스 로더에서 상위 클래스 로더 방향으로 클래스 로딩을 위임하는 것을 말한다. step description 1 Method Area에 클래스가 로드되어 있는지 확인한다. 로드되어 있다면 해당 클래스를 사용한다. 2 Method Area에 클래스가 로드되어 있지 않다면, 애플리케이션 클래스 로더에게 클래스 로드를 요청한다. 3 애플리케이션 클래스 로더는 확장 클래스로더에게 로딩을 요청한다. 4 확장 클래스 로더는 부트스트랩 클래스로더에게 로딩을 요청한다. 5 부트스트랩 클래스 로더는 부트스트랩 classpath에 요청받은 클래스가 있는지 확인한다. 요청받은 클래스가 존재하지 않는다면 확장 클래스로더가 요청을 수행하도록 한다. 6 확장 클래스 로더는 확장 classpath에 요청받은 클래스가 있는지 확인한다. 요청받은 클래스가 존재하지 않는다면 애플리케이션 클래스로더가 요청을 수행하도록 한다. 7 애플리케이션 클래스 로더는 애플리케이션 classpath에 요청받은 클래스가 있는지 확인한다.클래스가 존재하지 않는다면 java.lang.ClassNotFoundException이 발생한다. 가시성 제한 (Visibility) 하위 클래스 로더는 상위 클래스 로더에 의해 로드된 모든 클래스를 볼 수 있다. 하지만 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 볼 수 없다. 유일성 (Uniqueness) 상위 클래스 로더가 기존에 로딩해둔 클래스를 하위 클래스 로더가 다시 로딩하지 않도록하여 중복로딩을 방지하고 클래스의 유일성을 보장하기 위한 원칙이다. 3단계 작동 로딩 (loading) 위임 형식에 맞게 기본 클래스 로더들이 동작하여, 클래스의 바이트 코드를 가져온 후 Method Area에 로드시킨다. 링킹 (linking) step name description 1 검증 (verify) 로드한 클래스의 바이트 코드들이 자바 언어 명세와 JVM 명세에 맞게 구성되어있는지 검사한다. 2 준비 (prepare) 클래스가 필요로 하는 메모리를 할당하며 클래스내에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다. 3 분석 (resolve) 클래스 상수 풀의 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.[1] 초기화 (initialization) static initializer들을 수행하고 static 필드들을 설정된 값으로 초기화한다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:1","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"런타임 데이터 영역(Runtime Data Area) Runtime Data Area(이미지 출처: javarevisited.blogspot.com)\"\rRuntime Data Area(이미지 출처: javarevisited.blogspot.com)\r JVM이 Byte Code를 실행시키기 위해 OS로 부터 할당 받은 메모리 공간이다. Runtime Data Area는 5개의 부분으로 나뉜다. name description Method Area 모든 스레드가 공유하는 메모리 영역이며 JVM이 시작될 때 생성된다. 메서드 영역은 Permanent Area(또는 Permanent Generation)로 불리며 해당 영역의 GC 수행 여부는 JVM 벤더마다 다르다. 메서드 영역에는 아래의 데이터들이 위치한다. 런타임 상수 풀(Runtime Constant Pool)[2] .class 파일에서 constant_pool 테이블에 해당하는 영역이며 각 클래스와 인터페이스의 상수, 메서드와 필드에 대한 모든 참조를 담고 있는 테이블이다. 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다. FQCN (Fully Qualified Class Name)필드와 메서드 정보static 변수바이트 코드 Heap 동적으로 생성된 인스턴스를 저장하는 구역이며 GC는 해당영역에서 수행된다. Young GenerationEdenS0 (Survivor 0)S1 (Survivor 1)Old GenerationTenuredPermanent[3] JVM Language Stack 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택이며 JVM은 스택에 스택 프레임을 push, pop하는 연산을 수행한다. 스택 프레임은 아래와 같은 구조를 가진다.Local Variable ArrayOperand StackReference Constant Pool 예외 발생시 printStackTrace()메서드 호출 시 각 라인들은 하나의 stack frame을 표현한다. Native Method Stack 스레드마다 하나씩 존재하며unmanaged language로 작성된 코드를 위한 스택이다. PC Register 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 현재 수행중인 JVM 명령 주소를 가진다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:2","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"실행 엔진(Execution Engine) 실행 엔진은 런타임 데이터 영역에 클래스 로더를 통해 로드된 바이트코드를 실행하는 역할을 수행한다. 실행 엔진은 두 가지 방식으로 작동한다. name description 인터프리터 바이트 코드 명령어를 하나씩 읽어들여 해석하고 실행한다. JIT 컴파일러[4] 인터프리터의 단점[5]을 보완하기 위해 도입되었다. 인터프리터 방식으로 실행하다가 일정한 기준이 넘어가면 바이트 코드 전체를 컴파일하여 네이티브 코드를 생성하고 이후부터 해당 바이트 코드는 더 이상 인터프리터 방식으로 실행하는 것이 아닌 네이티브 코드를 통해 실행하는 방식을 취한다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:3","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"footnote [1] .class 파일은 실행 시 링크를 할 수 있도록 심볼릭 레퍼런스(Symbolic Reference)만을 가지고 있다. 런타임 시점에 실제 물리적인 주소인 다이렉트 레퍼런스(Direct Reference)로 대체되는 작업인 Dynamic linking이 일어난다. [2] 메서드 영역에 포함되나 JVM에서 핵심적인 동작을 수행하는 부분이기에 JVM 명세에서도 중요하게 기술해두고 있다. [3] Permanent Generation은 메서드 영역이다. 해당 영역의 GC 여부는 JVM 벤더에 따라 다르며 Heap 영역에 위치하지는 않으나 편의상 Heap 영역에 기술해두었다. [4] JIT는 AOT와 반대되는 성향을 가진다. [5] 코드를 줄단위로 해석해여 실행하기에 컴파일 방식보다 상대적으로 실행 속도가 느리다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:3:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"References javarevisited.blogspot.com Naver D2 - JVM internal https://www.artima.com/insidejvm/ed2/jvmP.html leeyh0216님의 블로그 - 자바의 클래스로더 알아보기 baeldung.com/java-classloaders ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:4:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["OOP"],"content":"싱글턴 정의 GoF 디자인 패턴에서 생성 패턴으로 분류된다. 클래스에 대한 인스턴스가 오직 1개만 생성되어야 하는 경우에 사용하는 패턴이다. 다중 스레드 환경이라면 싱글턴을 설계할 때 동시성(concurrency) 을 필히 고려하여 Thread-safe하게 만들어야한다. 다중 스레드 환경에서 동시성을 고려하지않고 싱글턴 클래스를 설계하면 인스턴스가 2개이상 생성될 수 있기에 예기치 못한 동작을 일으킬 수 있다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:1:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"싱글턴 패턴 구현 방식 Thread-safe한 구현방식에는 차이가 있어도 private constructor와 static method를 사용하는 것은 공통이다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"0. Thread-unsafe한 방식 public class Singleton { private Singleton instance; private Singleton() {} public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 싱글 스레드라면 해당 방식을 사용해도 문제없으나 다중 스레드 환경이라면 2개 이상의 인스턴스가 생성될 수 있다. 따라서 다중 스레드 환경에서는 해당 방식을 사용해서는 안된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:1","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"1. 이른 초기화 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 클래스 로더가 초기화하는 시점에 정적 바인딩을 통해 인스턴스를 메모리에 등록하는 방식 컴파일 시점에 인스턴스 생성 인스턴스 사용유무와 상관없이 컴파일 시점에 항상 인스턴스가 생성되어 메모리에 할당된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:2","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"2. 동기화 블럭 public class Singleton { private static Singleton instance; private Singleton() {} public static synchronzied Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 메서드에 동기화 블럭(synchronized 키워드 사용)을 지정하여 생성하는 방식 인스턴스가 필요한 시점에 동적바인딩하여 생성 인스턴스가 생성이 되었건 안되었건 동기화 블럭을 거치므로 성능이 상당히 저하 (Benchmarking Java Locks with Counters) ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:3","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"3. DCL (Double Checked Locking) public class Singleton { private volatile static Singleton instance; private Sigleton() {} public Singleton getInstance() { if(instance == null) { synchronized(Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; } } 동기화 블럭 방식의 문제점인 동기화 오버헤드를 개선한 방식 인스턴스가 생성되지 않은 경우(null인 경우)에만 동기화 블럭이 실행 흔치 않은 경우이나, DCL 사용시 문제가 되는 경우가 존재 ex) T1과 T2 스레드가 존재하며 인스턴스가 아직 생성되지 않은 상태에서 T1과 T2가 getInstance 메서드를 호출한다고 가정하였을 때, T1이 인스턴스 생성을 완전히 완료하기 전에 인스턴스에 대한 메모리 공간을 할당할 수 있다. 이 때, T2가 인스턴스에 대한 메모리가 할당된 것을 보고 인스턴스를 사용하려고 할 수 있는데 인스턴스의 생성이 완전히 완료된것이 아니므로 문제가 발생할 수 있다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:4","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"4. Enum public enum Singleton { INSTANCE; } class대신 enum을 사용하는 방식 복잡한 직렬화 상황 또는 리플렉션 상황에서 직렬화가 자동으로 지원되기에 인스턴스가 2개이상 생성되는 것을 막아준다. enum의 초기화는 컴파일 시점에 수행 Context 의존성이 있는 환경이라면 인스턴스의 메서드 등을 호출할때마다 Context 정보를 넘겨야할 수 있기에 오버헤드 발생 가능 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:5","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"5. Lazy Holder public class Singleton { private Singleton() {} private static class LazyHolder() { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return LazyHolder.INSTANCE; } } 동시성 문제를 해결하는데 volatile, synchronized 키워드를 사용하지 않으므로 성능이 뛰어나며 가장 많이 사용하는 방식이다. Singleton 클래스 내부에 LazyHolder 타입의 변수가 없으므로 클래스 로더는 초기화 때 LazyHolder를 초기화하지 않으며, getInstance 메서드를 호출할 때 클래스 로더에 의해 초기화가 수행된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:6","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"주의사항 다중 스레드 환경에서 Thread-safe를 보장해야하므로 stateless해야 한다. public class Singleton { private final OTHER_SINGLETON; // (1) 다른 싱글턴 인스턴스 참조는 가능 private Obejct object // (2) Static Area에 저장되므로 불가능 } 싱글턴은 상태 정보를 클래스 내부에 가지고 있으면 안된다. 하지만, 클래스 내부에서 다른 싱글턴 인스턴스를 참조하는 경우는 가능하다. 클래스 로더를 2개 이상 사용하면 싱글턴 인스턴스가 2개 이상 생성될수 있다. 이 경우 복수개의 인스턴스가 생성되지 않도록 클래스 로더를 지정해야한다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:7","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"스프링에서 싱글턴 사용예 스프링에서 어노테이션 설정 또는 xml 설정을 통해 IoC 컨테이너에게 제어권을 넘겨주어 빈을 생성할 수 있다. 빈을 등록할 때 아래의 예시처럼 scope를 지정가능하다. 이 때 기본 scope를 명시하지 않으면 기본적으로singleton으로 적용되어 빈이 생성된다. \u003c!-- xml을 사용한 방식 --\u003e \u003cbean id=\"...\" class=\"...\" scope=\"prototype\"\u003e \u003c/bean\u003e /* annotaton을 사용한 방식 */ // (1) @Component @Scope(\"prototype\") public class StudentInfo { ... } // (2) @Configuration public class ConfigurationBeanFactory { @Bean @Scope(\"prototype\") public StudentInfo StudentInfo(){ return new StudentInfo(); } } singleton (default) : IoC 컨테이너 내에 단 하나만 존재한다. prototype : 컨테이너에 빈을 요청할때마다 새로운 인스턴스 생성 request : HTTP 요청 하나당 하나의 인스턴스 생성 session : 하나의 세션당 하나의 인스턴스 생성 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"Bean을 Singleton으로 생성하는 이유 사용자로부터 요청이 발생하면 3계층(Presentation Layer - Business Layer - Persistence Layer)을 구성하는 객체들이 사용자 요청을 처리하여 결과를 응답한다. 매번 사용자 요청마다 새로운 객체를 생성하게되면 GC가 자주 수행되어 Stop-The-World가 발생하게되고 메모리 오버헤드가 발생할 수 있다. 이 문제를 해결하기위해 빈을 기본적으로 싱글턴으로 생성하며 Java 엔터프라이즈에서는 Service Object라는 개념을 사용한다. 대표적으로 Service Object라는 개념에 속하는 서블릿이 멀티 스레딩 환경에서 싱글턴으로 동작하며 사용자 요청 처리를 담당하는 스레드들이 서블릿을 공유하여 사용한다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:1","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"ApplicationContext 스프링에서 싱글턴을 관리하는 주체가 ApplicationContext이며 IoC 컨테이너, 스프링 컨테이너, 빈 팩토리, SingletonRegistry 등으로 불린다. ApplicationContext 다이어그램\"\rApplicationContext 다이어그램\r ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속하며, BeanFactory 인터페이스의 구현체가 DefaultListableBeanFactory이다. 대부분의 스프링 애플리케이션 컨텍스트는 DefaultListableBeanFactory를 빈 팩토리로 사용한다. DefaultListableBeanFactory 클래스는 SingletonBeanRegistry 인터페이스를 구현하고 있는데 해당 구현부가 싱글턴을 관리하는 기능들을 포함하고 있다. DefaultListableBeanFactory 다이어그램\"\rDefaultListableBeanFactory 다이어그램\r Java와 스프링에서 싱글턴 객체의 라이프사이클이 다르다. 자바는 클래스 로더 기준이며, 스프링에서는 ApplicationContext가 기준이다. 클래스 로더 기준이라는 것은 톰캣이 WAR 파일을 만들게 되면, WAR 파일 하나 당 클래스 로더가 1:1 관계로 배치가된다. 다른 WAR 파일은 참조가 불가능하다. ApplicationContext 기준이라는 것은 web.xml 에서 root context 하나와 servlet context 여러개를 등록할 수 있다. 이 때 각각의 context 들이 싱글턴 범위가 된다. root context와 servlet context 설명은 스프링의 컨텍스트참조 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:2","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"References webeveloper님의 블로그 - 싱글턴 패턴 Leopold님의 블로그 - Multi Thread 환경에서의 올바른 Singleton gmlwjd9405님의 블로그 - Spring Bean의 개념과 Bean Scope 종류 programmersought.com - Spring container core class kouzie님의 블로그 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:4:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["Algorithm"],"content":"KMP 정의 텍스트 내에서 특정 패턴을 검색하는데 사용하는 알고리즘이다. 예시로 워드나 브라우저등에서 Ctrl + F 키를 눌러 단어를 찾는 기능에 적용 가능하다. 텍스트 길이를 n, 패턴 길이를 m이라고 했을 때 brute-force로 수행하면 텍스트의 각 인덱스마다 패턴 길이만큼 반복을하여 $O(nm)$이 소요된다. KMP는 검색 효율을 높이기 위해 텍스트와 패턴의 구성 문자들을 비교해나가다가 불일치가 발생하면, 이전까지 일치했던 패턴의 부분 문자열내에서 접두사와 접미사가 일치한 길이로 패턴의 인덱스를 변경한 후 불일치한 부분과 다시 비교해나간다. 따라서, KMP를 사용하면 $O(n+m)$ 만으로 패턴 검색을 수행할 수 있다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:1:0","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"동작원리 ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:0","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"수행방식 패턴의 부분 문자열들을 가지고 접두사와 접미사가 일치하는 최대길이를 저장하는 테이블을 생성한다. 패턴의 0번째 인덱스부터 시작하여 길이가 1씩 증가하는 연속된 각 부분 문자열들의 접두사와 접미사가 일치하는 최대 길이를 구한다. {0, 1}, {0, 1, 2}, … , {0, 1, 2, …, m-1} (m은 패턴의 사이즈) 패턴 검색을 수행한다. 텍스트의 i번째 문자와 패턴의 j번째 문자를 비교한다. 문자가 일치하지 않고 j의 인덱스가 1이상 이라면 점프한다. (loop) j의 인덱스를 j-1번째 부분문자열의 접두사 접미사가 일치하는 최대길이로 변경한다. 해당 조건이 성립하지 않을때까지 반복한다. 문자가 일치한다면 j가 패턴의 마지막 인덱스라면 패턴을 찾았기에 다음 조회를 위해 j의 인덱스는 패턴의 접두사 접미사가 일치하는 최대길이로 변경한다. j가 패턴의 마지막 인덱스가 아니라면 j의 인덱스를 1만큼 증가시킨다. i의 인덱스를 1만큼 증가시킨다. 2-1부터 반복한다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:1","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"brute-force 수행 예시 텍스트: ABCDABCDABEE 패턴: ABCDABE 문자열 매칭 수행 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E brute-force를 사용한 방식은 문자열의 매 인덱스마다 패턴 일치 여부를 조회하므로 $O(nm)$의 시간복잡도를 가진다. 문자열과 패턴의 길이가 짧다면 큰 문제는 없을 것이다. 하지만, 문자열과 패턴의 길이가 긴 경우에 이렇게 무식한 방법으로 조회를 수행하는 것은 많은 수행시간을 요구하므로 비효율적이다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:2","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"KMP 수행 예시 텍스트: ABCDABCDABEE 패턴: ABCDABE 패턴의 부분 문자열들을 가지고 테이블 생성 i 부분 문자열 table[i] 0 A 0 1 AB 0 2 ABC 0 3 ABCD 0 4 ABCDA 1 5 ABCDAB 2 6 ABCDABE 0 문자열 매칭 수행 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E $i=6$, $j=6$에서 문자가 불일치 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 텍스트의 인덱스인 i의 위치는 그대로 두고 패턴 인덱스인 j를 table[5]의 값으로 변경한다. (점프) $i=6$, $j=2$를 비교 따라서, 위의 예시를 통해 KMP를 사용하면 중복되는 정보(접두사와 접미사의 일치 정보)를 활용하여 $O(n+m)$만에 문자열 매칭을 수행할 수 있는 것을 확인가능하다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:3","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"Code 백준 1786번 - 찾기문제를 통해 검증된 코드를 첨부한다. 코드는 테이블을 생성하는 init 함수와 문자열 탐색을 수행하는 kmp 함수로 나뉜다. init 함수와 kmp 함수의 코드는 유사하며 코드는 아래와 같이 나뉜다. init 함수 패턴의 1번째 부터 m-1 까지 반복 (m은 패턴의 사이즈) 점프하는 부분 table의 i번째 값 설정하는 부분 kmp 함수 텍스트의 0번째 부터 n-1 까지 반복 (n은 텍스트의 사이즈) 점프하는 부분 텍스트의 i번째 문자와 패턴의 j번째 문자 일치여부를 검사하는 부분 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e using namespace std; /* 테이블 생성 O(m) */ vector\u003cint\u003e init(string pattern) { int m = pattern.size(); int j = 0; vector\u003cint\u003e table(m, 0); //pattern의 부분 문자열 별로 접두사 접미사 일치 최대길이 계산 for(int i = 1; i \u003c m ; i++) { while(j \u003e 0 \u0026\u0026 pattern[i] != pattern[j]) { // 점프 j = table[j-1]; } if(pattern[i] == pattern[j]) { // i번째 table 값 설정 j++; table[i] = j; } } return table; } /* 문자열 매칭 O(n+m) */ vector\u003cint\u003e kmp(string str, string pattern) { vector\u003cint\u003e ans; // 패턴이 일치한 위치를 담는 배열 vector\u003cint\u003e table = init(pattern); // 접두사 접미사 table 생성 int n = str.size(); int m = pattern.size(); int j = 0; for(int i = 0 ; i \u003c n ; i++){ while(j \u003e 0 \u0026\u0026 str[i] != pattern[j]) { // 점프 수행 // j의 인덱스를 j-1 번째 부분 문자열의 접두사 접미사 일치 길이로 j = table[j-1]; } if(str[i] == pattern[j]) { // 문자열에서 패턴을 찾았다면 해당 패턴의 시작위치 추가 // j의 인덱스를 j번째 부분 문자열의 접두사 접미사 일치 길이로 if(j == m - 1){ ans.push_back(i - m + 1); j = table[j]; } else { j++; //문자만 일치한다면 j 증가 } } } return ans; } int main(){ string str, pattern; vector\u003cint\u003e matched; getline(cin, str); getline(cin, pattern); matched = kmp(str, pattern); cout \u003c\u003c matched.size() \u003c\u003c '\\n'; for(int pos : matched) { cout \u003c\u003c (pos + 1) \u003c\u003c ' '; } } ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:3:0","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"References bowbowbow님의 블로그 - “KMP : 문자열 검색 알고리즘” 안경잡이개발자님의 블로그 - KMP 알고리즘 ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:4:0","tags":["KMP"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"백트래킹 일반적으로 DFS나 BFS를 사용하여 탐색을 수행하면 모든 노드들을 탐색한다. 모든 노드를 탐색해야만하는 상황이라면 이러한 완전탐색(Full-Access) 방법을 취하는 것은 적절하다. 하지만, 모든 노드 중 특정 조건이 성립하는 노드만을 탐색하길 원한다면 DFS나 BFS는 목표하지 않은 경로도 탐색하게되므로 비효율적인 결과를 발생시킬수 있다. 백트래킹을 적용하면 유망성 검사를 통해 모든 노드를 탐색하는 것이 아닌 조건에 부합하지 않는 노드들은 배제를 시킨다. 이를 통해 완전탐색 수행시 발생하는 시간적 비효율을 획기적으로 단축시킬 수 있다. 요약하자면 백트래킹은 DFS에 유망성 검사를 결합한 가지치기 방법이라고 할 수 있다. ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:1:0","tags":["Back Tracking"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["Algorithm"],"content":"N-Queen 문제 : 백준 9663번 - N-Queen 백트래킹을 사용하여 해결할 수 있는 유명한 문제 중 하나인 N-Queen 문제를 통해 이해를 돕고자 한다. N-Queen문제란 N이 주어질 때 N×N 체스판에서 N개의 퀸을 배치할 수 있는 경우의 수를 구하는 문제다. 퀸 배치시 단순히 체스판 임의의 구역에 배치하면되는 것이 아닌, 각각의 퀸이 서로를 공격할 수 없는 구역에 배치되어야 한다. 즉, 아래의 경우는 성립할 수 없는 경우이다. 우선 ‘퀸이 서로를 공격할 수 있는 구역에는 놓이면 안된다’ 라는 조건을 고려하지 않고, 4×4 체스판에서 퀸 4개를 배치할 수 있는 모든 경우를 트리로 나타내보면 아래와 같다. $(1,1)$에 첫번째, $(2,1)$에 두번째, $(3,1)$에 세번째, $(4,1)$에 네번째 퀸을 배치 $(1,1)$에 첫번째, $(2,1)$에 두번째, $(3,1)$에 세번째, $(4,2)$에 네번째 퀸을 배치 … 이제 ‘퀸이 서로를 공격할 수 있는 구역에는 놓이면 안된다’ 라는 조건(유망성 검사)을 적용하여 트리의 시작점에서부터 탐색을 시작해보자. 첫번째 퀸을 $(1,1)$에 배치 두번째 퀸을 $(2,1)$에 배치 가능한가? 아니오. 두번째 퀸을 $(2,2)$에 배치 가능한가? 아니오. 두번째 퀸을 $(2,3)$에 배치 가능한가? 예. 두번째 퀸을 $(2,3)$에 배치 세번째 퀸을 $(3,1)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,2)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,3)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,4)$에 배치 가능한가? 아니오. 세번째 퀸이 놓일 수 있는 구역이 없다. 즉, $(2,3)$은 유망하지 못하므로 되추적을 진행하여 이전단계인 $(1,1)$에 첫번째 퀸을 배치하는 경우로 돌아간다. 첫번째 퀸을 $(1,1)$에 배치 두번째 퀸을 $(2,4)$에 배치 가능한가? 예. 두번째 퀸을 $(2,4)$에 배치 세번째 퀸을 $(3,1)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,2)$에 배치 가능한가? 예. 세번째 퀸을 $(3,2)$에 배치 네번째 퀸을 $(4,1)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,2)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,3)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,4)$에 배치 가능한가? 아니오. 네번째 퀸이 놓일 수 있는 구역이 없다. $(3,4)$에 세번째 퀸을 배치하는 경우는 유망하지 못하므로 되추적을 진행하여 이전 단계로 돌아간다. 두번째 퀸을 $(2,4)$에 배치 세번째 퀸을 $(3,3)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,4)$에 배치 가능한가? 아니오. 네번째 퀸을 배치할 수 있는 구역이 존재하지 않는다. 따라서 $(1,1)$에 첫번째 퀸을 배치하는 경우는 유망하지 못하다는 결론이 나오며 $(1,2)$부터 탐색을 이어나간다. 이후의 과정들은 위와 유사한 동작들이 반복되어 수행되기에 지면이 길어지므로 생략한다. 최종 정답의 도출 여부를 떠나 첫번째 퀸이 $(1,1)$ 위치에 유망한가 여부에 대해서만 놓고 봤을 때, ‘유망하지 않다.’ 라는 답을 도출하기까지 13번(1 + 4 + 4 + 4)의 노드 방문이 이루어졌다. 백트래킹을 수행하지 않고 DFS를 진행했을 때는 85(1 + 4 + 16 + 64)번의 노드를 방문해야하므로 백트래킹을 적용하면 수행시간의 효율이 향상된다는 것을 알 수 있다. ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:2:0","tags":["Back Tracking"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["Algorithm"],"content":"Code 백준에서 AC를 받은 코드를 첨부한다. #include \u003ciostream\u003e#include \u003cvector\u003e#define MAX 16; using namespace std; int n, ans = 0; vector\u003cint\u003e col; //유망한 위치인가? bool possible(int cur){ for(int i=1; i \u003c cur; i++){ //가로 세로 검사 if(col[i] == col[cur]) return false; //대각 검사 if(abs(cur - i) == abs(col[cur] - col[i])) return false; } return true; } void dfs(int row){ if(row \u003e n){ ans++; return; } for(int i=1; i\u003c=n; i++){ col[row] = i; if(possible(row)){ dfs(row + 1); } else{ col[row] = 0; } } } int main() { cin \u003e\u003e n; col.resize(n+1); for(int i=1; i\u003c=n; i++){ col[1] = i; //1,i부터 시작 dfs(2); } cout \u003c\u003c ans; } ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:2:1","tags":["Back Tracking"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 9466번 - 텀 프로젝트 학생들은 프로젝트 팀을 구성하기 위해 프로젝트를 함께하고 싶은 1명의 학생을 선택해야한다. 자기자신을 선택하는 경우도 있다. (이 경우도 팀으로 간주) 학생들이$(s_1, s_2, …, s_r)$이라 할 때, r=1이고 $s_1$이 $s_1$을 선택하는 경우나, $s_1$이 $s_2$를 선택하고, $s_2$가 $s_3$를 선택하고,…, $s_{r-1}$이 $s_r$을 선택하고, $s_r$이 $s_1$을 선택하는 경우에만 한 팀이 될 수 있다. 학생들이 선택한 결과를 통해 팀으로 구성되지 않는 학생들의 수를 출력한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:1:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"Solution 문제에서 팀이 성립되는 경우는 선택한 학생들간에 사이클을 형성하는지 여부이다. 따라서 학생들이 선택한 결과를 통해 팀으로 구성되지 않는 학생들을 구하라는 말인즉슨 사이클을 형성하지 않는 학생들을 구하라는 말과도 동일하다. 문제에서 주어진 예시케이스를 가지고 방향 그래프를 구성하면 다음과 같아지며 학생들 중 $(3)$, $(4, 6, 7)$이 사이클을 형성하고 있음을 확인할 수 있다. 1 2 3 4 5 6 7 3 1 3 7 3 4 6 사이클을 판별하기 위해 DFS를 사용할 수도 있고, 위상정렬을 사용할 수도 있다. 본인은 문제를 해결하기위해 위상정렬을 사용하였다. 위상정렬은 사이클이 발생한 노드들에 대해서는 위상정렬을 수행할 수 없게되므로 DAG(Directed Acyclic Graph)에만 적용이 가능하다. 즉, 사이클이 발생하기 전까지는 위상정렬을 수행할 수 있다. 이 부분에 착안하여 본 문제에서는 요구하고 있는 사이클이 발생하지 않은 학생들의 수를 구하기위해 사이클이 발생하기 전까지 정렬이 수행되는 횟수를 카운트해주기로 했다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:2:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"수행단계 (위상정렬) 학생들이 선택한 결과를 통해 방향 그래프를 구성한다. 첫번째부터 마지막까지 순회하여 진입차수가 0인 학생들을 큐에 삽입한다. 사이클이 발생하지 않는 경우를 카운트한다. 큐의 front에 있는 노드와 연결된 다른 노드들의 진입차수를 1만큼 감소시킨다. 연결된 다른 노드 중 진입차수가 0인 노드를 큐에 삽입한다. 큐의 front에 있는 노드를 제거한다. 카운트 값을 증가시킨다. 큐가 empty일 때까지 반복한다. 주어진 예시케이스를 가지고 위의 단계들을 수행하면 3명의 학생들이 팀을 구성하지 못하는 것을 알 수 있다. 진입차수가 0인 2와 5를 큐에 삽입한다. (카운트는 2) 큐에서 2를 꺼내고 2와 연결된 1의 진입차수를 감소시킨다. 이 때, 1은 진입차수가 0이 되므로 큐에 삽입한다. (카운트는 3) 큐에서 5를 꺼내고 5와 연결된 3의 진입차수를 감소시킨다. 큐에서 1을 꺼내고 1이랑 연결된 3의 진입차수를 감소시킨다. 큐가 비었으므로 반복을 종료한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:2:1","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"Code ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:3:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"위상정렬을 사용한 코드 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int main() { ios::sync_with_stdio(false); cin.tie(NULL); int tc; cin \u003e\u003e tc; while(tc-- \u003e 0){ int n, ans = 0; vector\u003cvector\u003cint\u003e\u003e graph; vector\u003cint\u003e indegree; queue\u003cint\u003e q; cin \u003e\u003e n; graph.resize(n+1); indegree.resize(n+1); //그래프 생성 for(int from=1; from\u003c=n; from++){ int to; cin \u003e\u003e to; graph[from].push_back(to); indegree[to]++; } //진입차수가 0인 그래프 탐색 for(int i=1; i\u003c=n; i++){ if(indegree[i] == 0) q.push(i); } while(!q.empty()){ int cur = q.front(); ans++; q.pop(); //진입차수 제거 for(int next : graph[cur]){ indegree[next] -= 1; //새롭게 진입차수가 0이 되는 노드 삽입 if(indegree[next] == 0){ q.push(next); } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } } ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:3:1","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 17472번 - 다리 만들기 2 나라는 섬들로 이루어지고, 모든 섬을 다리로 연결하려고 한다. N×M 크기의 지도에서 1은 땅 0은 바다를 나타내며 섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말한다. 섬과 섬간의 다리는 직선인 경우(가로, 세로)에만 성립하며 다리의 길이가 2이상 되어야한다. 모든 섬을 연결하는 다리 길이의 최솟값을 출력하며 모든 섬을 연결하는 것이 불가능한 경우에는 -1을 출력하도록 한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:1:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"Solution MST를 구하는 문제이다. 다른 일반적인 MST 문제는 정점의 번호와 간선 및 비용이 친절하게 주어지나, 이 문제는 지도를 통해 정점, 간선 및 비용을 직접 구해야한다. BFS(또는 DFS)와 크루스칼을 조합하여 문제를 해결하는 방식이다보니 재미있게 풀었다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:2:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"수행단계 섬들을 만든다 BFS또는 DFS를 통해 섬들을 탐색한다. 각 섬들에 인덱스를 매긴다. 각 섬들을 잇는 모든 다리들을 구한다. 각 섬들을 구성하는 좌표마다 가로, 세로 탐색을 수행한다. 탐색 시 바다라면 카운트 값을 증가시킨다. 탐색 시 땅이라면 인덱스 값을 확인한다. 탐색이 시작된 땅의 인덱스값과 현재 도달한 땅의 인덱스 값이 다르면 카운트 값이 2이상인지 조회한다. 카운트 값이 2이상이라면 간선 리스트에 시작 인덱스, 종료 인덱스, 카운트 값을 하나의 간선 정보로 하여 포함시킨다. 최소신장트리를 구한다. 간선 리스트에 포함된 간선들의 비용을 기준으로하여 정렬한다. Union-find를 사용하여 MST를 구성하며 find가 수행될때마다 간선의 비용을 누적시키고 MST에 포함되는 노드 갯수를 1씩 증가시킨다. MST에 포함된 노드갯수와 섬들의 갯수 일치여부를 검사한다. 갯수가 일치하면 누적된 간선 비용 값을 출력한다. 갯수가 불일치시 -1을 출력한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:2:1","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"Code 원본 배열(지도)에 정점의 인덱스 값을 할당해도 되겠지만, 본인은 unordered_map을 사용하여 해싱하는 방식으로 풀었다. 문제를 해결하는 것 외에도 본인만의 코딩컨벤션을 정립해서 읽기 쉬운 코드가 될 수 있도록 노력을 기울여야겠다. #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cunordered_map\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e #define LAND 1 #define LEN 11 #define MAX 7 using namespace std; int country[LEN][LEN]; bool visit[LEN][LEN]; int dx[] = {1, -1, 0, 0}; int dy[] = {0, 0, 1, -1}; unordered_map\u003cint, int\u003e vertex_index; int sz = 1; vector\u003cvector\u003cint\u003e\u003e edge; //from ,to, cost int root[MAX]; int depth[MAX]; //union by rank int hash_func(int y, int x){ return y*10 + x; } void get_vertex(int m, int n){ // y, x queue\u003cpair\u003cint,int\u003e\u003e q; for(int i=1; i\u003c=m; i++){ for(int j=1; j\u003c=n; j++){ if(country[i][j] == LAND \u0026\u0026 !visit[i][j]){ q.push({i,j}); //y,x visit[i][j] = true; while(!q.empty()){ pair\u003cint,int\u003e tmp = q.front(); for(int k=0; k\u003c4; k++){ int y = tmp.first + dy[k]; int x = tmp.second + dx[k]; if(1 \u003c= x \u0026\u0026 x \u003c= n \u0026\u0026 1 \u003c= y \u0026\u0026 y\u003c= m){ if(country[y][x] == LAND \u0026\u0026 !visit[y][x]){ q.push({y, x}); visit[y][x] = true; } } } q.pop(); vertex_index[hash_func(tmp.first,tmp.second)] = sz; } sz++; } } } sz--; } void find_edge(int y, int x, bool flag){ for(int i=1; i\u003c=y; i++){ int from = 0, to = 0, cost = 0; for(int j=1; j\u003c=x; j++){ int node = flag ? country[i][j] : country[j][i]; if(node == LAND){ int tmp = flag ? vertex_index[hash_func(i,j)] : vertex_index[hash_func(j,i)]; if(from == 0){ from = tmp; } else{ to = tmp; if(from != to){ //to를 만난 경우 if(cost \u003e= 2){ edge.push_back({from, to, cost}); } cost = 0; from = to; to = 0; } else cost = 0; } } else if(from != 0) cost++; } } } void get_edge(int m, int n){ find_edge(m, n, true); //horizontal find_edge(n, m, false); //vertical } bool cmp(vector\u003cint\u003e \u0026t, vector\u003cint\u003e \u0026u){ return t[2] \u003c u[2]; //cost 기준 } void init(int n){ for(int i=1; i\u003c=n; i++){ root[i] = i; depth[i] = 0; } } int find(int node){ if(root[node] == node){ return node; } else{ return root[node] = find(root[node]); } } bool do_union(int x, int y){ x = find(x); y = find(y); if(x==y) return false; if(depth[x] \u003c depth[y]){ root[x] = y; } else{ root[y] = x; if(depth[x] == depth[y]){ depth[x]++; } } return true; } int main() { int m, n, cnt = 0, answer = 0; cin \u003e\u003e m \u003e\u003e n; for(int i=1; i\u003c=m; i++){ for(int j=1; j\u003c=n; j++){ cin \u003e\u003e country[i][j]; } } get_vertex(m, n); get_edge(m, n); sort(edge.begin(), edge.end(), cmp); init(MAX - 1); for(vector\u003cint\u003e e : edge){ if(do_union(e[0], e[1])){ answer += e[2]; cnt++; } if(cnt == sz-1) break; } if(sz \u003c 2 || cnt != sz - 1) answer = -1; cout \u003c\u003c answer; } ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:3:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 8972번 - 미친 아두이노 SWEA에 나올법한 구현 문제이다. 아래의 과정을 통해서 시뮬레이션한 결과를 출력하며, 미친 아두이노와 플레이어(종수)의 아두이노가 동일한 좌표에 위치하면 시뮬레이션을 종료시키고 “kraj X\"라는 문자열을 출력한다. (X는 시뮬레이션이 종료된 단계) 먼저, 종수가 아두이노를 8가지 방향(수직,수평,대각선)으로 이동시키거나, 그 위치에 그대로 놔둔다. 종수의 아두이노가 미친 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되며, 종수는 게임을 지게 된다. 미친 아두이노는 8가지 방향 중에서 종수의 아두이노와 가장 가까워 지는 방향으로 한 칸 이동한다. 즉, 종수의 위치를 $(r1,s1)$, 미친 아두이노의 위치를 $(r2, s2)$라고 했을 때, $|r1-r2| + |s1-s2|$가 가장 작아지는 방향으로 이동한다. 미친 아두이노가 종수의 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되고, 종수는 게임을 지게 된다. 2개 또는 그 이상의 미친 아두이노가 같은 칸에 있는 경우에는 큰 폭발이 일어나고, 그 칸에 있는 아두이노는 모두 파괴된다. ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:1:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"Solution 이 문제의 핵심은 2개또는 그 이상의 미친 아두이노 존재시 파괴라는 점이다. 이 부분을 염두에 두고 시뮬레이션 코드를 작성해야하는데 본인은 이를 간과하고 알고리즘을 설계했다가 낭패를 봤다. 문제를 풀다가 아두이노가 미쳐버리는게 아니라 내가 미쳐버릴뻔 했다.. ㅎㅎ 미친 아두이노가 이동하는 좌표에 다른 미친 아두이노가 존재할때 파괴를 시키면 다음과 같은 경우에서 올바른 결과를 보장하지 못한다. 이동 시 미친 아두이노가 존재하면 파괴 (잘못된 경우) $(3,3)$에서 $(3,2)$로 이동 $(2,2)$에서 $(3,2)$로 이동 따라서, 모든 미친 아두이노가 이동 후에 좌표가 겹치는지 여부를 검사한 후 겹친다면 폭팔을 수행해야한다. 올바른 경우 $(3,3)$에서 $(3,2)$로 이동 $(2,2)$에서 $(3,2)$로 이동 $(3,2)$에서 $(4,1)$로 이동 모든 아두이노 이동 후 겹치는좌표 폭팔 ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:2:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"수행단계 종수를 이동시킨다. 이동시키고자 하는 위치에 미친 아두이노가 존재하면 return '.' 이라면 종수의 위치 갱신 및 map 갱신(새로운 좌표에 ‘I’ 할당, 기존 좌표에 '.' 할당) 미친 아두이노를 이동시킨다. 8가지 방향 중 $| r1 - r2 | + | s1 - s2 |$가 최소인 방향을 설정한다. (범위를 벗어나는 좌표라면 continue) 이동시키고자 하는 위치에 종수가 존재하면 return 미친 아두이노의 위치만 갱신 미친 아두이노들이 이동한 좌표에서 충돌여부를 검사한다. 충돌이 발생한 미친 아두이노들은 리스트에서 제거 충돌이 발생하지 않은 미친 아두이노들의 위치 값을 통해 map 갱신(새로운 좌표에 ‘R’ 할당, 기존 좌표에 '.' 할당) 1번부터 재반복한다. ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:2:1","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"Code 코드를 다 작성하고 제출하니 시간초과 판정을 받았다. ㅂㄷㅂㄷ… 기존 코드에서는 위 수행단계 3의 과정을위해 아래의 코드로 작성하였는데, 이 경우 각각의 미친 아두이노가 나머지 모든 미친 아두이노와 값을 비교하기 때문에 $O(N^2)$이 소요된다. //R와 충돌 검사 및 폭팔 처리 for(int i=0; i \u003c crazy.size(); i++){ if(check[i]) continue; bool bomb = false; int ty = crazy[i].first; int tx = crazy[i].second; for(int j=0; j \u003c crazy.size(); j++){ if(i == j) continue; int uy = crazy[j].first; int ux = crazy[j].second; if(ty == uy \u0026\u0026 tx == ux){ check[j] = true; bomb = true; } } if(!bomb) map[ty][tx] = CRAZY; else check[i] = true; } 시복잡도를 최소화 시키기 위해 미친 아두이노들의 좌표값들을 정렬해준 후 순회하며 아래의 단계를 수행하는 것으로 변경하였다. crazy[i]의 충돌여부 검사시 j는 i 인덱스로 설정 crazy[i]와 crazy[j+1]이 같지 않을때까지 j인덱스 증가 i의 인덱스와 j의 인덱스가 같다면 crazy[i]는 충돌이 일어나지 않았으므로 map 갱신 및 새로운 리스트에 삽입 i와 j의 인덱스가 다르다면 i ~ j-1까지는 충돌이 발생. 다음 비교를 위해서 i는 j 인덱스로 변경 따라서 시복잡도는 $O(NlogN)$이 되게된다. //R와 충돌 검사 및 폭팔 처리 sort(crazy.begin(), crazy.end()); vector\u003cpair\u003cint,int\u003e\u003e temp; for(int i=0; i \u003c crazy.size(); i++){ int j = i; //충돌이 발생하는 인덱스는 건너뛰기 while(j \u003c crazy.size() \u0026\u0026 crazy[i] == crazy[j+1]){ j++; } if(i==j){ // 충돌이 발생하지 않은 경우 int cy = crazy[i].first; int cx = crazy[i].second; map[cy][cx] = CRAZY; temp.push_back(crazy[i]); } else i = j; // 인덱스 변경 (건너뛰기) } crazy = temp; 전체 코드는 아래와 같다. #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e#define LEN 101 #define CRAZY 'R' #define PLAYER 'I' #define EMPTY '.' #define INF 1e9 using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(NULL); int R, C, step = 0; vector\u003cstring\u003e map; pair\u003cint,int\u003e player; vector\u003cpair\u003cint,int\u003e\u003e crazy; string command; bool is_end = false; int dx[] = {0,-1,0,1,-1,0,1,-1,0,1}; // 1 ~ 9, 0은 dummy int dy[] = {0,1,1,1,0,0,0,-1,-1,-1}; // 입력 cin \u003e\u003e R \u003e\u003e C; for(int i=0; i\u003cR; i++){ string row; cin \u003e\u003e row; map.push_back(row); for(int j=0; j\u003cC; j++){ if(map[i][j] == CRAZY) crazy.push_back({i, j}); // y,x if(map[i][j] == PLAYER) player = {i, j}; } } cin \u003e\u003e command; for(char c : command){ int cmd = c - '0'; // 플레이어 이동 int py = player.first + dy[cmd]; int px = player.second + dx[cmd]; step++; is_end = map[py][px] == CRAZY; //R과 충돌 검사 if(is_end) break; map[player.first][player.second] = EMPTY; map[py][px] = PLAYER; player = {py, px}; //미친 아두이노 이동 for(int i=0; i \u003c crazy.size(); i++){ int cy, cx, judge = INF; for(int k=1; k\u003c=9; k++){ if(k==5) continue; int ty = crazy[i].first + dy[k]; int tx = crazy[i].second + dx[k]; if(0 \u003e ty || ty \u003e= R || 0 \u003e tx || tx \u003e= C) continue; int val = abs(py - ty) + abs(px - tx); if(judge \u003e val){ judge = val; cy = ty; cx = tx; } } is_end = map[cy][cx] == PLAYER; // I와 충돌 검사 if(is_end) goto escape; map[crazy[i].first][crazy[i].second] = EMPTY; crazy[i] = {cy, cx}; } //R와 충돌 검사 및 폭팔 처리 sort(crazy.begin(), crazy.end()); vector\u003cpair\u003cint,int\u003e\u003e temp; for(int i=0; i \u003c crazy.size(); i++){ int j = i; //충돌이 발생하는 인덱스는 건너뛰기 while(j \u003c crazy.size() \u0026\u0026 crazy[i] == crazy[j+1]){ j++; } if(i==j){ // 충돌이 발생하지 않은 경우 int cy = crazy[i].first; int cx = crazy[i].second; map[cy][cx] = CRAZY; temp.push_back(crazy[i]); } else i = j; // 인덱스 변경 (건너뛰기) } crazy = temp; } escape:; if(is_end){ cout \u003c\u003c \"kraj \" \u003c\u003c step; } else{ for(int i=0; i\u003cR; i++){ cout \u003c\u003c map[i] \u003c\u003c '\\n'; } } } ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:3:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"}]