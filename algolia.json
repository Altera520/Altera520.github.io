[{"categories":["Programming"],"content":"자바8 이전의 날짜 클래스 자바8 이전에 사용하던 java.util.Date와 java.util.Calendar 등은 많은 문제점이 존재하였다. 대표적인 문제점을 추리면 다음과 같다. 불변성(Immutable)을 보장하지 않는다. 불변성을 보장하지 않기에 Thread-safe하지 않다. Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.Month, 2 - 1); Date date = new Date(); date.setTime(new Date()); 클래스 이름이 Date인데 시간까지 다룬다. int 상수 필드의 남용 Date와 Calendar의 불편한 역할 분담 Month 계산이 혼동스럽다. (1월을 나타내는 상수 값이 0부터 시작한다) // 1월이 아닌 2월이 된다. calendar.set(Calendar.Month, 1); // 1월을 표시하기 위해서는 상수 값 0이나 // Calendar에서 제공하는 static 필드를 사용해야 한다. calendar.set(Calendar.Month, Canlendar.JANUARY); java.util.Date 하위 클래스의 문제 java.util.Date를 상속한 클래스는 java.sql.Date와 java.sql.Timestamp가 있다. java.sql.Date의 경우 Comparable 인터페이스에 대한 정의를 클래스 선언에서 하지 않아 Comparable과 관련한 선언들을 복잡하게 만들었으며, java.sql.Timestamp는 equals() 선언의 대칭성을 위반하였다.[1] 위에 언급된 대표적인 문제점 말고도 많은 문제점들이 존재한다. 자바 8부터는 개선된 날짜 및 시간 관련 클래스들을 제공하니 시간처리와 관련된 기능들을 다룰 때 가능하면 최대한 자바 8의 날짜 및 시간 관련 클래스들을 활용하자. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:1:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"자바8의 Date-Time API 자바 8에서는 java.time패키지에 LocalDateTime과 ZonedDateTime등을 추가하여 이전보다 향상된 날짜와 시간계산 기능을 가능하게 하였다. JSR-310 스펙으로 구현된 Date Time API는 아래의 디자인 철학을 가진다. Clear Fluent Immutable Extensible ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"인류용 시간(human time) |------------------------ZonedDateTime------------------------| |---------------OffsetDateTime---------------| |--------LocalDateTime--------| |--LocalDate--|---LocalTime---|--ZoneOffset--|---ZoneRegion---| 2021-02-18 13:00:00 +09:00 Asia/Seoul 인류용 시간은 연, 월, 일, 시, 분, 초 등을 표현하며 인간이 쉽게 사용하고 읽을 수 있는 시간 형식을 말한다. LocalDateTime, LocalDate, LocalTime은 서버 배포시 서버가 실행되는 국가에 따라 시간이 자동 세팅되므로 유의해야한다. 따라서 국내에서 서비스 한다면 LocalDateTime으로 처리하고, 글로벌 서비스까지 한다면 timezone이 추가된 ZonedDateTime 사용을 고려해야 한다. human time 관련 클래스 name description LocalDate, LocalTime, LocalDateTime 시간대 정보(Zone Offset, Zone Region)가 포함되지 않은 클래스이다. LocalDate: 특정 날짜LocalTime: 특정 시간LocalDateTime: 일시 ZoneOffset UTC 기준으로 시간(Time Offset)을 나타낸 것이다.ZoneOffset은 ZoneId를 상속한다. ZoneRegion Time Zone을 나타낸 것이다. 예시로 한국의 경우 KST는 타임존의 이름이며 이에 대응되는 ZoneRegion은 Asia/Seoul이다. ZoneRegion은 ZoneId를 상속하나 public 클래스가 아니므로 ZoneId를 통해서만 생성 가능하다. OffsetDateTime LocalDateTime에 ZoneOffSet의 정보까지 붙은 클래스이다. ZonedDateTime OffsetDateTime에 ZoneRegion의 정보까지 붙은 클래스이다. ZoneOffset과 ZoneRegion을 보면 차이가 없어보인다. 하지만, API를 설계할 때 아무 이유없이 차이도 없는 클래스를 두개나 정의하지 않았을 것이다. 둘의 차이는 Time Transition Rule[2]을 포함하는지 포함하지 않는지에 따라 다르다. ZoneOffset: Time Transition Rule을 포함하지 않는 ZoneRules를 가진다. ZoneRegion: Time Transition Rule을 포함할 수도 있고 포함하지 않을 수도 있다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:1","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"기계용 시간(machine time) 기계용 시간이란 UTC 기준으로 EPOCH (1970년 1월 1일 0시 0분 0초)부터 현재에 이르기까지의 타임스탬프를 말한다. 즉, 인간이 읽고 쓰기에는 적합하지 않으나 기계에서 사용하기에는 적합한 시간을 의미한다. 많은 개발자들이 Long 타입 UNIX Timestamp를 사용한다. 타임스탬프 사용 이유로는 정수형을 이용한 정렬 및 기타 연산등에서 다른 타입보다 빠른 연산속도를 가지기 때문이다. 하지만, UNIX Timestamp의 경우 Year 2038 problem을 가지고 있기에 자바8에서는 Timestamp의 문제를 해결하기 위해 Instant 클래스를 추가하였다. Instant 사용예시 현재 시간의 타임스탬프 값 구하기 Instant current = Instant.now(); long epochSecond = current.getEpochSecond(); long epochMilli = current.toEpochMilli(); Instant to ZonedDateTime/ ZonedDateTime to Instant // Instant to ZonedDateTime Instant instant = Instant.now(); ZonedDateTime krTime = instant.atZone(ZoneId.of(\"Asia/Seoul\")); // ZonedDateTime to Instant ZonedDateTime krTime = ZonedDateTime.of(2020, 8, 18, 6, 57, 38, ZoneId.of(\"Asia/Seoul\")); Instant instant = krTime.toInstant(); Instant to LocaldDateTime/ LocalDateTime to Instant // Instant to LocalDateTime Instant instant = Instant.now(); LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC); // LocalDateTime to Instant LocalDateTime localDateTime = LocalDateTime.of(2020, 8, 18, 6, 57, 38); Instant instant = localDateTime.toInstant(ZoneOffset.UTC); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:2","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"기타 유용한 메서드들 Instant는 초 또는 밀리초 단위로 시간을 더하거나 빼는 메서드 및 비교하는 메서드 등을 제공 Instant instant = Instant.now(); instant.plusSeconds(10); instant.minusSeconds(10); instant.isBefore(Instant.now()); instant.isAfter(Instant.now()); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:3","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"기간의 표현 자바8에서 추가된 time 패키지 내에는 기간을 표현하기 위한 Duration과 Period가 존재한다. Duration (시간 기반) Duration은 두 시간 사이의 간격을 초나 나노초 단위로 나타내기 위해 사용한다. Duration 사용예시 LocalTime startTime = LocalTime.of(11, 23, 40); LocalTime endTime = LocalTime.of(11, 24, 50, 800); Duration duration = Duration.between(startTime, endTime); long sec = d.getSeconds(); long nano = d.getNano(); Period (날짜 기반) Period는 두 날짜 사이의간격을 년, 월, 일 단위로 나타내기 위해 사용한다. Period 사용예시 LocalDate startDate = LocalDate.of(2014, 3, 1); LocalDate endDate = LocalDate.of(2015, 4, 5); Period p = Period.between(startDate, endDate); int year = p.getYears(); int month = p.getMonths(); int day = p.getDays(); ChronoUnit ChronoUnit을 사용하면 Duration 또는 Period 객체 생성 없이 날짜 및 시간의 간격을 표현할 수 있다. ChronoUnit 사용예시 LocalTime startTime = LocalTime.of(11, 23, 40); LocalTime endTime = LocalTime.of(11, 24, 50, 800); long hours = ChronoUnit.HOURS.between(startTime, endTime); long minutes = ChronoUnit.MINUTES.between(startTime, endTime); long seconds = ChronoUnit.SECONDS.between(startTime, endTime); LocalDate startDate = LocalDate.of(2014, 3, 1); LocalDate endDate = LocalDate.of(2015, 4, 5); long months = ChronoUnit.MONTHS.between(startDate, endDate); long weeks = ChronoUnit.WEEKS.between(startDate, endDate); long days = ChronoUnit.DAYS.between(startDate, endDate); ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:2:4","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"JDBC에서의 컨버팅 및 Legacy에서 마이그레이션 자바8 이상의 버전이 되면서 자바8 이전에 사용되던 Date, Timestamp등은 레거시가 되었다. 자바의 시간관련 타입들을 적절하게 사용하기위해서 기록해둔다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"JDBC에서의 컨버팅 형태 JDBC에서는 Java와 DB 스키마 사이에서 타입 컨버팅을 아래에 따라 자동 변환 시킨다. JDBC Converting\" JDBC Converting ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:1","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"Legacy에서 마이그레이션시 권장 타입 Legacy Migration\" Legacy Migration 1부 - 특징 및 람다 표현식 2부 - 스트림 API 3부 - java.time 패키지 4부 - 나즈혼(Nashorn) 5부 - 기타 변경사항 ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:3:2","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"footnote [1] Date 타입과 TimeStamp 타입을 섞어 쓰면 a.equals(b)가 true라도 b.equals(a)는 false인 경우가 생길 수 있다. [2] Time Transition Rule이란 일광 절약 시간제(DST, Daylight Saving Time)와 같이 표준시를 부분 조정하는 규칙을 말한다. ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:4:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"References https://www.daleseo.com/java8-duration-period/ https://madplay.github.io/post/java8-date-and-time https://perfectacle.github.io/2018/09/26/java8-date-time/ https://stackoverflow.com/questions/32437550/whats-the-difference-between-instant-and-localdatetime https://d2.naver.com/helloworld/645609 https://umbum.dev/922 ","date":"2021-02-18","objectID":"/posts/2021-02-18-java8-features-3rd/:5:0","tags":["Java"],"title":"[Java8의 변경사항] 3. 날짜와 시간 계산","uri":"/posts/2021-02-18-java8-features-3rd/"},{"categories":["Programming"],"content":"Java8의 특징 자바 8은 2014년 3월에 출시된 LTS 버전이며 제공하는 주요기능은 다음과 같다. 람다 표현식: 함수형 프로그래밍 Stream API: 시퀀셜한 데이터의 추상화된 사용 java.time 패키지: 개선된 Date, Time API 제공 나즈혼(Nashorn): 자바스크립트의 새로운 엔진 도입 LTS(Long-Term-Support) 버전 LTS 버전 배포 주기는 3년이며 지원기간은 5년이상으로서 production환경에서는 LTS 버전을 권장한다. 비LTS 버전의 경우 배포 주기는 6개월이며 지원기간은 배포 이후 6개월로 제공기간이 짧다. ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:1:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"람다 표현식 (Lambda Expression) 람다 표현식이란 익명 클래스의 한개 메서드를 표현식으로 나타낸 것이다. 람다식의 장단점은 아래와 같다. 람다식 장점 코드가 간결해지고 가독성이 향상된다. 병렬 프로그래밍이 용이하다. 람다식 단점 디버깅이 복잡해진다. 람다식으로 작성된 함수는 재사용이 불가능하다. 정리하자면 람다 표현식 사용 시 작성된 코드의 가독성을 높일 수 있으나 무분별한 사용은 코드가 지저분해질 수 있을뿐더러 디버깅이 까다로워지니 적절히 사용해야할 것이다. 람다표현식 작성법 (매개변수 리스트) -\u003e {함수 몸체} 매개변수가 하나인 경우 ()를 생략가능하다. 매개변수의 타입은 생략 가능하나 명시할 수도 있다. (생략시 컴파일러가 타입 추론) 함수 몸체가 한 줄인 경우 {}와 return을 생략 가능하다. ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"함수형 인터페이스 (Functional interface) 람다 표현식을 사용하기 위해서는 우선, 함수형 인터페이스가 필요하다. 함수형 인터페이스란 단 한개의 추상 메서드만을 가지는 인터페이스를 말하며 @FunctionalInterface 어노테이션을 사용하여 함수형 인터페이스임을 명시할 수 있다. 아래의 코드는 함수형 인터페이스를 정의하고 이를 익명 클래스와 람다식으로 사용하는 예제이다. @FunctionalInterface public interface LambdaExample { //abstract void run(); abstract 생략 가능 void run(); } ... public class Program { public static void main(String[] args) { /* 익명 클래스로 사용 */ LambdaExample le1 = new LambdaExample() { @Override public void run() { System.out.println(\"run\"); } } le1.run(); /* 람다 표현식으로 사용 */ LambdaExample le2 = () -\u003e System.out.println(\"run\"); le2.run(); } } 함수형 인터페이스를 개발자가 직접 정의해서 사용할수도 있으나, 자바8에서 기본적으로 제공해주는 함수형 인터페이스들이 java.util.function에 존재한다. 기본 제공 함수형 인터페이스 name description Function\u003cT, V\u003e apply : T 타입을 받아서 V 타입을 리턴compose : 함수 조합, 파라미터로 들어온 함수가 우선 수행andThen : 함수 조합, 파라미터로 들어온 함수가 이후 수행 UnaryOperator\u003cT\u003e Function\u003cT, T\u003e를 extends apply : T 타입을 받아서 T 타입을 리턴 BiFunction\u003cT, U, V\u003e apply : T, U 타입을 받아서 V 타입을 리턴 BinaryOperator\u003cT\u003e BiFunction\u003cT, T, T\u003e를 extends apply : T 타입 두개를 받아서 T 타입을 리턴 Consumer\u003cT\u003e accept : T 타입을 받아서 동작 수행 (리턴 X)andThen : 함수조합 Predicate\u003cT\u003e test : T 타입을 받아서 boolean 리턴 and : 함수조합or : 함수조합negate : 함수조합 Supplier\u003cT\u003e get : T 타입의 값을 제공 ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:1","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"변수 캡쳐 (Variable Capture) 람다 표현식 함수 몸체에서 외부의 변수를 참조하는 것을 말한다. 참조된 변수의 앞에는 final을 붙여야 하나 자바8에서 부터는 생략 가능하다. (effective final: final이 붙지 않을 경우 동시성 문제가 발생할 수 있기에 컴파일러가 방지한다.) public void run() { int number = 100; //final 키워드 생략, number 변수는 람다식 내부에서 참조 IntConsumer consumer = (base) -\u003e System.out.println(base * number); consumer.accept(2); } 또한, 로컬 클래스와 익명 클래스에서는 쉐도잉이 발생하나 람다식에서는 쉐도잉이 발생하지 않는다. 즉 로컬 클래스와 익명 클래스의 scope와 이를 감싸고 있는 scope는 다르지만, 람다식의 경우 람다식을 감싸고 있는 scope와 동일하다. 변수의 쉐도잉 (Variable Shadowing) 쉐도잉이란 하위 scope와 상위 scope에서 각각 동일한 이름의 변수가 존재할 때, 하위 scope에서 해당 이름을 가진 변수를 사용하게 되면 상위 scope의 변수는 가려져 하위 scope의 변수가 사용되는 것을 말한다. public void run() { int number = 100; // 로컬 클래스 class LocalClass { void print() { int number = 1; System.out.println(number); // 1이 출력 } } // 익명 클래스 Runnable anonymousClass = new Runnable() { @Override public void run() { int number = 2; System.out.println(number); // 2가 출력 } }; // 람다식 Runnable lambdaExpression = () -\u003e { //int number = 3; // 불가능, 컴파일 에러 발생 System.out.println(number); // 100이 출력 }; } ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:2","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"메서드 레퍼런스 람다식을 직접 정의 할수도 있으나, 람다식이 단순히 특정 메서드나 생성자를 호출하는 것이라면 메서드 레퍼런스를 사용하여 간단히 표현할 수 있다. 메서드 레퍼런스 사용법 유형 형식 static 메서드 참조 타입::static 메서드 명 인스턴스 메서드 참조 참조 변수명::인스턴스 메서드 명 생성자 참조 타입::new 키워드 임의 객체의 메서드 참조 타입::인스턴스 메서드 명 이 중, 임의 객체의 메서드 참조는 인자로 전달되는 인스턴스를 특정하지 않는 경우에 사용한다. 즉 , 함수 객체를 적용하는 시점에 인자로 들어오는 인스턴스를 알려주며 주로 스트림 파이프라인에서 매핑과 필터 함수에 사용된다. 아래의 코드는 메서드 레퍼런스 사용 예시이다. public class Sample() { public Sample() { ... } public Sample(String arg) { ... } public static String concatStatic(String str) { return str + \"static\"; } public String concatInstance(String str) { return str + \"instance\"; } } ... public void run() { // 람다식 UnaryOperator\u003cString\u003e concat1 = string -\u003e string + \"someting\"; // static 메서드 레퍼런스 UnaryOperator\u003cString\u003e concat2 = string -\u003e Sample::concatStatic; // 인스턴스 레퍼런스 Sample sample1 = new Sample(); UnaryOperator\u003cString\u003e concat2 = string -\u003e sample1::concatInstance; // 기본 생성자 레퍼런스 Supplier\u003cSample\u003e sample2 = Sample::new; // 인자있는 생성자 레퍼런스 Function\u003cString, Sample\u003e sample3 = Sample::new; // 임의 객체의 메서드 참조 String[] list = {\"alpha\", \"beta\", \"gamma\"}; Arrays.sort(list, String::compareToIgnoreCase); } 1부 - 특징 및 람다 표현식 2부 - 스트림 API 3부 - java.time 패키지 4부 - 나즈혼(Nashorn) 5부 - 기타 변경사항 ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:2:3","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"References ","date":"2021-02-17","objectID":"/posts/2021-02-17-java8-features-1st/:3:0","tags":["Java","Lambda"],"title":"[Java8의 변경사항] 1. 특징 및 람다 표현식","uri":"/posts/2021-02-17-java8-features-1st/"},{"categories":["Programming"],"content":"JVM 정의 javac를 통해 생성된 Byte Code를 OS에 맞게 해석하여 실행시켜주는 역할을 수행한다. JVM은 크게 봤을 때 5개의 컴포넌트로 나뉜다. Class Loader Execution Engine Runtime Date Area JNI Native method library 이 5개의 컴포넌트 중 JNI와 Native method library를 제외한 3가지 컴포넌트에 대해 정리하고자 한다. Java Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce)\" Java Virtual Machine Architecture (이미지 출처: medium.com/everythingatonce) ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:1:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"JVM 구성 요소 ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"클래스 로더(Class Loader) 클래스 로더는 JRE의 일부로서 런타임시 클래스들에 대한 정의를 런타임 데이터 영역에 동적 로드하는 역할을 수행한다. 클래스 로딩시에는 Thread-safe가 보장되고 한 번 로드된 클래스는 언로드 될 수 없다. 3가지 클래스 로더 Class Loader Hierarchy (출처: medium.com/@minfuyang)\" Class Loader Hierarchy (출처: medium.com/@minfuyang) Bootstrap class loader 네이티브 코드로 구현되어 있으며 3가지 기본 클래스 로더 중에서 최상위 클래스 로더이다. JVM이 실행되면 가장 우선적으로 부트스트랩 로더가 메모리상에 적재되며 이후 자바 클래스들을 로드할 수 있는 java.lang.ClassLoader를 포함하여 최상위 클래스(Object, String, …)들을 로딩한다. java8 : ${JAVA_HOME}/jre/lib/rt.jar내에 있는 모든 JDK 내부 클래스를 로드한다. java9 : rt.jar이 제거되고 /lib내에 모듈화되어 포함되었다. Extention class loader 기본 자바 API를 제외한 확장클래스들을 로드한다. java8 : URLClassLoader를 상속, jre/lib/ext내의 모든 클래스를 로드 java9 : URLClassLoader대신 BuiltinClassLoader를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, Platform Class Loader로 명칭 변경 Application class loader 사용자가 지정한 $CLASSPATH내의 모든 클래스들을 로드한다. 즉, 애플리케이션의 클래스들을 로드한다. java9 : URLClassLoader대신 BuiltinClassLoader를 상속받아 ClassLoader 클래스 내부 static 클래스로 구현, System Class Loader로 명칭 변경 User-Defined class loader 기본 클래스 로더가 아니다. 만약 3가지 클래스 로더가 사용하는 classpath외에 위치한 클래스를 로드시키고자 한다면 java.lang.ClassLoader 클래스를 상속하고 findClass메서드를 오버라이드한 커스텀 클래스 로더를 만들면된다. 3가지 원칙 클래스로더가 지켜야하는 3가지 원칙은 java.lang.ClassLoader의 loadClass메서드에 코드로 구현되어 있다. 위임 (Delegation) 클래스 로딩이 필요할 때 하위 클래스 로더에서 상위 클래스 로더 방향으로 클래스 로딩을 위임하는 것을 말한다. step description 1 Method Area에 클래스가 로드되어 있는지 확인한다. 로드되어 있다면 해당 클래스를 사용한다. 2 Method Area에 클래스가 로드되어 있지 않다면, 애플리케이션 클래스 로더에게 클래스 로드를 요청한다. 3 애플리케이션 클래스 로더는 확장 클래스로더에게 로딩을 요청한다. 4 확장 클래스 로더는 부트스트랩 클래스로더에게 로딩을 요청한다. 5 부트스트랩 클래스 로더는 부트스트랩 classpath에 요청받은 클래스가 있는지 확인한다. 요청받은 클래스가 존재하지 않는다면 확장 클래스로더가 요청을 수행하도록 한다. 6 확장 클래스 로더는 확장 classpath에 요청받은 클래스가 있는지 확인한다. 요청받은 클래스가 존재하지 않는다면 애플리케이션 클래스로더가 요청을 수행하도록 한다. 7 애플리케이션 클래스 로더는 애플리케이션 classpath에 요청받은 클래스가 있는지 확인한다.클래스가 존재하지 않는다면 java.lang.ClassNotFoundException이 발생한다. 가시성 제한 (Visibility) 하위 클래스 로더는 상위 클래스 로더에 의해 로드된 모든 클래스를 볼 수 있다. 하지만 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 볼 수 없다. 유일성 (Uniqueness) 상위 클래스 로더가 기존에 로딩해둔 클래스를 하위 클래스 로더가 다시 로딩하지 않도록하여 중복로딩을 방지하고 클래스의 유일성을 보장하기 위한 원칙이다. 3단계 작동 로딩 (loading) 위임 형식에 맞게 기본 클래스 로더들이 동작하여, 클래스의 바이트 코드를 가져온 후 Method Area에 로드시킨다. 링킹 (linking) step name description 1 검증 (verify) 로드한 클래스의 바이트 코드들이 자바 언어 명세와 JVM 명세에 맞게 구성되어있는지 검사한다. 2 준비 (prepare) 클래스가 필요로 하는 메모리를 할당하며 클래스내에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다. 3 분석 (resolve) 클래스 상수 풀의 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.[1] 초기화 (initialization) static initializer들을 수행하고 static 필드들을 설정된 값으로 초기화한다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:1","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"런타임 데이터 영역(Runtime Data Area) Runtime Data Area(이미지 출처: javarevisited.blogspot.com)\" Runtime Data Area(이미지 출처: javarevisited.blogspot.com) JVM이 Byte Code를 실행시키기 위해 OS로 부터 할당 받은 메모리 공간이다. Runtime Data Area는 5개의 부분으로 나뉜다. name description Method Area 모든 스레드가 공유하는 메모리 영역이며 JVM이 시작될 때 생성된다. 메서드 영역은 Permanent Area(또는 Permanent Generation)로 불리며 해당 영역의 GC 수행 여부는 JVM 벤더마다 다르다. 메서드 영역에는 아래의 데이터들이 위치한다. 런타임 상수 풀(Runtime Constant Pool)[2] .class 파일에서 constant_pool 테이블에 해당하는 영역이며 각 클래스와 인터페이스의 상수, 메서드와 필드에 대한 모든 참조를 담고 있는 테이블이다. 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다. FQCN (Fully Qualified Class Name)필드와 메서드 정보static 변수바이트 코드 Heap 동적으로 생성된 인스턴스를 저장하는 구역이며 GC는 해당영역에서 수행된다. Young GenerationEdenS0 (Survivor 0)S1 (Survivor 1)Old GenerationTenuredPermanent[3] JVM Language Stack 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택이며 JVM은 스택에 스택 프레임을 push, pop하는 연산을 수행한다. 스택 프레임은 아래와 같은 구조를 가진다.Local Variable ArrayOperand StackReference Constant Pool 예외 발생시 printStackTrace()메서드 호출 시 각 라인들은 하나의 stack frame을 표현한다. Native Method Stack 스레드마다 하나씩 존재하며unmanaged language로 작성된 코드를 위한 스택이다. PC Register 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 현재 수행중인 JVM 명령 주소를 가진다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:2","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"실행 엔진(Execution Engine) 실행 엔진은 런타임 데이터 영역에 클래스 로더를 통해 로드된 바이트코드를 실행하는 역할을 수행한다. 실행 엔진은 두 가지 방식으로 작동한다. name description 인터프리터 바이트 코드 명령어를 하나씩 읽어들여 해석하고 실행한다. JIT 컴파일러[4] 인터프리터의 단점[5]을 보완하기 위해 도입되었다. 인터프리터 방식으로 실행하다가 일정한 기준이 넘어가면 바이트 코드 전체를 컴파일하여 네이티브 코드를 생성하고 이후부터 해당 바이트 코드는 더 이상 인터프리터 방식으로 실행하는 것이 아닌 네이티브 코드를 통해 실행하는 방식을 취한다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:2:3","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"footnote [1] .class 파일은 실행 시 링크를 할 수 있도록 심볼릭 레퍼런스(Symbolic Reference)만을 가지고 있다. 런타임 시점에 실제 물리적인 주소인 다이렉트 레퍼런스(Direct Reference)로 대체되는 작업인 Dynamic linking이 일어난다. [2] 메서드 영역에 포함되나 JVM에서 핵심적인 동작을 수행하는 부분이기에 JVM 명세에서도 중요하게 기술해두고 있다. [3] Permanent Generation은 메서드 영역이다. 해당 영역의 GC 여부는 JVM 벤더에 따라 다르며 Heap 영역에 위치하지는 않으나 편의상 Heap 영역에 기술해두었다. [4] JIT는 AOT와 반대되는 성향을 가진다. [5] 코드를 줄단위로 해석해여 실행하기에 컴파일 방식보다 상대적으로 실행 속도가 느리다. ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:3:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["Programming"],"content":"References javarevisited.blogspot.com Naver D2 - JVM internal https://www.artima.com/insidejvm/ed2/jvmP.html leeyh0216님의 블로그 - 자바의 클래스로더 알아보기 baeldung.com/java-classloaders ","date":"2021-01-12","objectID":"/posts/2021-01-12-jvm/:4:0","tags":["Java"],"title":"JVM 구조","uri":"/posts/2021-01-12-jvm/"},{"categories":["OOP"],"content":"싱글턴 정의 GoF 디자인 패턴에서 생성 패턴으로 분류된다. 클래스에 대한 인스턴스가 오직 1개만 생성되어야 하는 경우에 사용하는 패턴이다. 다중 스레드 환경이라면 싱글턴을 설계할 때 동시성(concurrency) 을 필히 고려하여 Thread-safe하게 만들어야한다. 다중 스레드 환경에서 동시성을 고려하지않고 싱글턴 클래스를 설계하면 인스턴스가 2개이상 생성될 수 있기에 예기치 못한 동작을 일으킬 수 있다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:1:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"싱글턴 패턴 구현 방식 Thread-safe한 구현방식에는 차이가 있어도 private constructor와 static method를 사용하는 것은 공통이다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"0. Thread-unsafe한 방식 public class Singleton { private Singleton instance; private Singleton() {} public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 싱글 스레드라면 해당 방식을 사용해도 문제없으나 다중 스레드 환경이라면 2개 이상의 인스턴스가 생성될 수 있다. 따라서 다중 스레드 환경에서는 해당 방식을 사용해서는 안된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:1","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"1. 이른 초기화 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 클래스 로더가 초기화하는 시점에 정적 바인딩을 통해 인스턴스를 메모리에 등록하는 방식 컴파일 시점에 인스턴스 생성 인스턴스 사용유무와 상관없이 컴파일 시점에 항상 인스턴스가 생성되어 메모리에 할당된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:2","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"2. 동기화 블럭 public class Singleton { private static Singleton instance; private Singleton() {} public static synchronzied Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 메서드에 동기화 블럭(synchronized 키워드 사용)을 지정하여 생성하는 방식 인스턴스가 필요한 시점에 동적바인딩하여 생성 인스턴스가 생성이 되었건 안되었건 동기화 블럭을 거치므로 성능이 상당히 저하 (Benchmarking Java Locks with Counters) ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:3","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"3. DCL (Double Checked Locking) public class Singleton { private volatile static Singleton instance; private Sigleton() {} public Singleton getInstance() { if(instance == null) { synchronized(Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; } } 동기화 블럭 방식의 문제점인 동기화 오버헤드를 개선한 방식 인스턴스가 생성되지 않은 경우(null인 경우)에만 동기화 블럭이 실행 흔치 않은 경우이나, DCL 사용시 문제가 되는 경우가 존재 ex) T1과 T2 스레드가 존재하며 인스턴스가 아직 생성되지 않은 상태에서 T1과 T2가 getInstance 메서드를 호출한다고 가정하였을 때, T1이 인스턴스 생성을 완전히 완료하기 전에 인스턴스에 대한 메모리 공간을 할당할 수 있다. 이 때, T2가 인스턴스에 대한 메모리가 할당된 것을 보고 인스턴스를 사용하려고 할 수 있는데 인스턴스의 생성이 완전히 완료된것이 아니므로 문제가 발생할 수 있다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:4","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"4. Enum public enum Singleton { INSTANCE; } class대신 enum을 사용하는 방식 복잡한 직렬화 상황 또는 리플렉션 상황에서 직렬화가 자동으로 지원되기에 인스턴스가 2개이상 생성되는 것을 막아준다. enum의 초기화는 컴파일 시점에 수행 Context 의존성이 있는 환경이라면 인스턴스의 메서드 등을 호출할때마다 Context 정보를 넘겨야할 수 있기에 오버헤드 발생 가능 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:5","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"5. Lazy Holder public class Singleton { private Singleton() {} private static class LazyHolder() { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return LazyHolder.INSTANCE; } } 동시성 문제를 해결하는데 volatile, synchronized 키워드를 사용하지 않으므로 성능이 뛰어나며 가장 많이 사용하는 방식이다. Singleton 클래스 내부에 LazyHolder 타입의 변수가 없으므로 클래스 로더는 초기화 때 LazyHolder를 초기화하지 않으며, getInstance 메서드를 호출할 때 클래스 로더에 의해 초기화가 수행된다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:6","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"주의사항 다중 스레드 환경에서 Thread-safe를 보장해야하므로 stateless해야 한다. public class Singleton { private final OTHER_SINGLETON; // (1) 다른 싱글턴 인스턴스 참조는 가능 private Obejct object // (2) Static Area에 저장되므로 불가능 } 싱글턴은 상태 정보를 클래스 내부에 가지고 있으면 안된다. 하지만, 클래스 내부에서 다른 싱글턴 인스턴스를 참조하는 경우는 가능하다. 클래스 로더를 2개 이상 사용하면 싱글턴 인스턴스가 2개 이상 생성될수 있다. 이 경우 복수개의 인스턴스가 생성되지 않도록 클래스 로더를 지정해야한다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:2:7","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"스프링에서 싱글턴 사용예 스프링에서 어노테이션 설정 또는 xml 설정을 통해 IoC 컨테이너에게 제어권을 넘겨주어 빈을 생성할 수 있다. 빈을 등록할 때 아래의 예시처럼 scope를 지정가능하다. 이 때 기본 scope를 명시하지 않으면 기본적으로singleton으로 적용되어 빈이 생성된다. \u003c!-- xml을 사용한 방식 --\u003e \u003cbean id=\"...\" class=\"...\" scope=\"prototype\"\u003e \u003c/bean\u003e /* annotaton을 사용한 방식 */ // (1) @Component @Scope(\"prototype\") public class StudentInfo { ... } // (2) @Configuration public class ConfigurationBeanFactory { @Bean @Scope(\"prototype\") public StudentInfo StudentInfo(){ return new StudentInfo(); } } singleton (default) : IoC 컨테이너 내에 단 하나만 존재한다. prototype : 컨테이너에 빈을 요청할때마다 새로운 인스턴스 생성 request : HTTP 요청 하나당 하나의 인스턴스 생성 session : 하나의 세션당 하나의 인스턴스 생성 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"Bean을 Singleton으로 생성하는 이유 사용자로부터 요청이 발생하면 3계층(Presentation Layer - Business Layer - Persistence Layer)을 구성하는 객체들이 사용자 요청을 처리하여 결과를 응답한다. 매번 사용자 요청마다 새로운 객체를 생성하게되면 GC가 자주 수행되어 Stop-The-World가 발생하게되고 메모리 오버헤드가 발생할 수 있다. 이 문제를 해결하기위해 빈을 기본적으로 싱글턴으로 생성하며 Java 엔터프라이즈에서는 Service Object라는 개념을 사용한다. 대표적으로 Service Object라는 개념에 속하는 서블릿이 멀티 스레딩 환경에서 싱글턴으로 동작하며 사용자 요청 처리를 담당하는 스레드들이 서블릿을 공유하여 사용한다. ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:1","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"ApplicationContext 스프링에서 싱글턴을 관리하는 주체가 ApplicationContext이며 IoC 컨테이너, 스프링 컨테이너, 빈 팩토리, SingletonRegistry 등으로 불린다. ApplicationContext 다이어그램\" ApplicationContext 다이어그램 ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속하며, BeanFactory 인터페이스의 구현체가 DefaultListableBeanFactory이다. 대부분의 스프링 애플리케이션 컨텍스트는 DefaultListableBeanFactory를 빈 팩토리로 사용한다. DefaultListableBeanFactory 클래스는 SingletonBeanRegistry 인터페이스를 구현하고 있는데 해당 구현부가 싱글턴을 관리하는 기능들을 포함하고 있다. DefaultListableBeanFactory 다이어그램\" DefaultListableBeanFactory 다이어그램 Java와 스프링에서 싱글턴 객체의 라이프사이클이 다르다. 자바는 클래스 로더 기준이며, 스프링에서는 ApplicationContext가 기준이다. 클래스 로더 기준이라는 것은 톰캣이 WAR 파일을 만들게 되면, WAR 파일 하나 당 클래스 로더가 1:1 관계로 배치가된다. 다른 WAR 파일은 참조가 불가능하다. ApplicationContext 기준이라는 것은 web.xml 에서 root context 하나와 servlet cotnext 여러개를 등록할 수 있다. 이 때 각각의 context 들이 싱글턴 범위가 된다. root context와 servlet context 설명은 스프링의 컨텍스트참조 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:3:2","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["OOP"],"content":"References webeveloper님의 블로그 - 싱글턴 패턴 Leopold님의 블로그 - Multi Thread 환경에서의 올바른 Singleton gmlwjd9405님의 블로그 - Spring Bean의 개념과 Bean Scope 종류 programmersought.com - Spring container core class kouzie님의 블로그 ","date":"2021-01-06","objectID":"/posts/2021-01-06-singleton/:4:0","tags":["Java","Design Pattern","Spring"],"title":"싱글턴(Singleton)","uri":"/posts/2021-01-06-singleton/"},{"categories":["Algorithm"],"content":"KMP 정의 텍스트 내에서 특정 패턴을 검색하는데 사용하는 알고리즘이다. 예시로 워드나 브라우저등에서 Ctrl + F 키를 눌러 단어를 찾는 기능에 적용 가능하다. 텍스트 길이를 n, 패턴 길이를 m이라고 했을 때 brute-force로 수행하면 텍스트의 각 인덱스마다 패턴 길이만큼 반복을하여 $O(nm)$이 소요된다. KMP는 검색 효율을 높이기 위해 텍스트와 패턴의 구성 문자들을 비교해나가다가 불일치가 발생하면, 이전까지 일치했던 패턴의 부분 문자열내에서 접두사와 접미사가 일치한 길이로 패턴의 인덱스를 변경한 후 불일치한 부분과 다시 비교해나간다. 따라서, KMP를 사용하면 $O(n+m)$ 만으로 패턴 검색을 수행할 수 있다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:1:0","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"동작원리 ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:0","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"수행방식 패턴의 부분 문자열들을 가지고 접두사와 접미사가 일치하는 최대길이를 저장하는 테이블을 생성한다. 패턴의 0번째 인덱스부터 시작하여 길이가 1씩 증가하는 연속된 각 부분 문자열들의 접두사와 접미사가 일치하는 최대 길이를 구한다. {0, 1}, {0, 1, 2}, … , {0, 1, 2, …, m-1} (m은 패턴의 사이즈) 패턴 검색을 수행한다. 텍스트의 i번째 문자와 패턴의 j번째 문자를 비교한다. 문자가 일치하지 않고 j의 인덱스가 1이상 이라면 점프한다. (loop) j의 인덱스를 j-1번째 부분문자열의 접두사 접미사가 일치하는 최대길이로 변경한다. 해당 조건이 성립하지 않을때까지 반복한다. 문자가 일치한다면 j가 패턴의 마지막 인덱스라면 패턴을 찾았기에 다음 조회를 위해 j의 인덱스는 패턴의 접두사 접미사가 일치하는 최대길이로 변경한다. j가 패턴의 마지막 인덱스가 아니라면 j의 인덱스를 1만큼 증가시킨다. i의 인덱스를 1만큼 증가시킨다. 2-1부터 반복한다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:1","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"brute-force 수행 예시 텍스트: ABCDABCDABEE 패턴: ABCDABE 문자열 매칭 수행 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E brute-force를 사용한 방식은 문자열의 매 인덱스마다 패턴 일치 여부를 조회하므로 $O(nm)$의 시간복잡도를 가진다. 문자열과 패턴의 길이가 짧다면 큰 문제는 없을 것이다. 하지만, 문자열과 패턴의 길이가 긴 경우에 이렇게 무식한 방법으로 조회를 수행하는 것은 많은 수행시간을 요구하므로 비효율적이다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:2","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"KMP 수행 예시 텍스트: ABCDABCDABEE 패턴: ABCDABE 패턴의 부분 문자열들을 가지고 테이블 생성 i 부분 문자열 table[i] 0 A 0 1 AB 0 2 ABC 0 3 ABCD 0 4 ABCDA 1 5 ABCDAB 2 6 ABCDABE 0 문자열 매칭 수행 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E $i=6$, $j=6$에서 문자가 불일치 인덱스 0 1 2 3 4 5 6 7 8 9 10 11 텍스트 A B C D A B C D A B E E 패턴 A B C D A B E 텍스트의 인덱스인 i의 위치는 그대로 두고 패턴 인덱스인 j를 table[5]의 값으로 변경한다. (점프) $i=6$, $j=2$를 비교 따라서, 위의 예시를 통해 KMP를 사용하면 중복되는 정보(접두사와 접미사의 일치 정보)를 활용하여 $O(n+m)$만에 문자열 매칭을 수행할 수 있는 것을 확인가능하다. ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:2:3","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"Code 백준 1786번 - 찾기문제를 통해 검증된 코드를 첨부한다. 코드는 테이블을 생성하는 init 함수와 문자열 탐색을 수행하는 kmp 함수로 나뉜다. init 함수와 kmp 함수의 코드는 유사하며 코드는 아래와 같이 나뉜다. init 함수 패턴의 1번째 부터 m-1 까지 반복 (m은 패턴의 사이즈) 점프하는 부분 table의 i번째 값 설정하는 부분 kmp 함수 텍스트의 0번째 부터 n-1 까지 반복 (n은 텍스트의 사이즈) 점프하는 부분 텍스트의 i번째 문자와 패턴의 j번째 문자 일치여부를 검사하는 부분 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e using namespace std; /* 테이블 생성 O(m) */ vector\u003cint\u003e init(string pattern) { int m = pattern.size(); int j = 0; vector\u003cint\u003e table(m, 0); //pattern의 부분 문자열 별로 접두사 접미사 일치 최대길이 계산 for(int i = 1; i \u003c m ; i++) { while(j \u003e 0 \u0026\u0026 pattern[i] != pattern[j]) { // 점프 j = table[j-1]; } if(pattern[i] == pattern[j]) { // i번째 table 값 설정 j++; table[i] = j; } } return table; } /* 문자열 매칭 O(n+m) */ vector\u003cint\u003e kmp(string str, string pattern) { vector\u003cint\u003e ans; // 패턴이 일치한 위치를 담는 배열 vector\u003cint\u003e table = init(pattern); // 접두사 접미사 table 생성 int n = str.size(); int m = pattern.size(); int j = 0; for(int i = 0 ; i \u003c n ; i++){ while(j \u003e 0 \u0026\u0026 str[i] != pattern[j]) { // 점프 수행 // j의 인덱스를 j-1 번째 부분 문자열의 접두사 접미사 일치 길이로 j = table[j-1]; } if(str[i] == pattern[j]) { // 문자열에서 패턴을 찾았다면 해당 패턴의 시작위치 추가 // j의 인덱스를 j번째 부분 문자열의 접두사 접미사 일치 길이로 if(j == m - 1){ ans.push_back(i - m + 1); j = table[j]; } else { j++; //문자만 일치한다면 j 증가 } } } return ans; } int main(){ string str, pattern; vector\u003cint\u003e matched; getline(cin, str); getline(cin, pattern); matched = kmp(str, pattern); cout \u003c\u003c matched.size() \u003c\u003c '\\n'; for(int pos : matched) { cout \u003c\u003c (pos + 1) \u003c\u003c ' '; } } ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:3:0","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"References bowbowbow님의 블로그 - “KMP : 문자열 검색 알고리즘” 안경잡이개발자님의 블로그 - KMP 알고리즘 ","date":"2021-01-01","objectID":"/posts/2021-01-01-kmp/:4:0","tags":["KMP","Theory"],"title":"KMP : 문자열 매칭 알고리즘","uri":"/posts/2021-01-01-kmp/"},{"categories":["Algorithm"],"content":"백트래킹 일반적으로 DFS나 BFS를 사용하여 탐색을 수행하면 모든 노드들을 탐색한다. 모든 노드를 탐색해야만하는 상황이라면 이러한 완전탐색(Full-Access) 방법을 취하는 것은 적절하다. 하지만, 모든 노드 중 특정 조건이 성립하는 노드만을 탐색하길 원한다면 DFS나 BFS는 목표하지 않은 경로도 탐색하게되므로 비효율적인 결과를 발생시킬수 있다. 백트래킹을 적용하면 유망성 검사를 통해 모든 노드를 탐색하는 것이 아닌 조건에 부합하지 않는 노드들은 배제를 시킨다. 이를 통해 완전탐색 수행시 발생하는 시간적 비효율을 획기적으로 단축시킬 수 있다. 요약하자면 백트래킹은 DFS에 유망성 검사를 결합한 가지치기 방법이라고 할 수 있다. ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:1:0","tags":["Back Tracking","Theory"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["Algorithm"],"content":"N-Queen 문제 : 백준 9663번 - N-Queen 백트래킹을 사용하여 해결할 수 있는 유명한 문제 중 하나인 N-Queen 문제를 통해 이해를 돕고자 한다. N-Queen문제란 N이 주어질 때 N×N 체스판에서 N개의 퀸을 배치할 수 있는 경우의 수를 구하는 문제다. 퀸 배치시 단순히 체스판 임의의 구역에 배치하면되는 것이 아닌, 각각의 퀸이 서로를 공격할 수 없는 구역에 배치되어야 한다. 즉, 아래의 경우는 성립할 수 없는 경우이다. 우선 ‘퀸이 서로를 공격할 수 있는 구역에는 놓이면 안된다’ 라는 조건을 고려하지 않고, 4×4 체스판에서 퀸 4개를 배치할 수 있는 모든 경우를 트리로 나타내보면 아래와 같다. $(1,1)$에 첫번째, $(2,1)$에 두번째, $(3,1)$에 세번째, $(4,1)$에 네번째 퀸을 배치 $(1,1)$에 첫번째, $(2,1)$에 두번째, $(3,1)$에 세번째, $(4,2)$에 네번째 퀸을 배치 … 이제 ‘퀸이 서로를 공격할 수 있는 구역에는 놓이면 안된다’ 라는 조건(유망성 검사)을 적용하여 트리의 시작점에서부터 탐색을 시작해보자. 첫번째 퀸을 $(1,1)$에 배치 두번째 퀸을 $(2,1)$에 배치 가능한가? 아니오. 두번째 퀸을 $(2,2)$에 배치 가능한가? 아니오. 두번째 퀸을 $(2,3)$에 배치 가능한가? 예. 두번째 퀸을 $(2,3)$에 배치 세번째 퀸을 $(3,1)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,2)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,3)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,4)$에 배치 가능한가? 아니오. 세번째 퀸이 놓일 수 있는 구역이 없다. 즉, $(2,3)$은 유망하지 못하므로 되추적을 진행하여 이전단계인 $(1,1)$에 첫번째 퀸을 배치하는 경우로 돌아간다. 첫번째 퀸을 $(1,1)$에 배치 두번째 퀸을 $(2,4)$에 배치 가능한가? 예. 두번째 퀸을 $(2,4)$에 배치 세번째 퀸을 $(3,1)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,2)$에 배치 가능한가? 예. 세번째 퀸을 $(3,2)$에 배치 네번째 퀸을 $(4,1)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,2)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,3)$에 배치 가능한가? 아니오. 네번째 퀸을 $(4,4)$에 배치 가능한가? 아니오. 네번째 퀸이 놓일 수 있는 구역이 없다. $(3,4)$에 세번째 퀸을 배치하는 경우는 유망하지 못하므로 되추적을 진행하여 이전 단계로 돌아간다. 두번째 퀸을 $(2,4)$에 배치 세번째 퀸을 $(3,3)$에 배치 가능한가? 아니오. 세번째 퀸을 $(3,4)$에 배치 가능한가? 아니오. 네번째 퀸을 배치할 수 있는 구역이 존재하지 않는다. 따라서 $(1,1)$에 첫번째 퀸을 배치하는 경우는 유망하지 못하다는 결론이 나오며 $(1,2)$부터 탐색을 이어나간다. 이후의 과정들은 위와 유사한 동작들이 반복되어 수행되기에 지면이 길어지므로 생략한다. 최종 정답의 도출 여부를 떠나 첫번째 퀸이 $(1,1)$ 위치에 유망한가 여부에 대해서만 놓고 봤을 때, ‘유망하지 않다.’ 라는 답을 도출하기까지 13번(1 + 4 + 4 + 4)의 노드 방문이 이루어졌다. 백트래킹을 수행하지 않고 DFS를 진행했을 때는 85(1 + 4 + 16 + 64)번의 노드를 방문해야하므로 백트래킹을 적용하면 수행시간의 효율이 향상된다는 것을 알 수 있다. ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:2:0","tags":["Back Tracking","Theory"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["Algorithm"],"content":"Code 백준에서 AC를 받은 코드를 첨부한다. #include \u003ciostream\u003e#include \u003cvector\u003e#define MAX 16; using namespace std; int n, ans = 0; vector\u003cint\u003e col; //유망한 위치인가? bool possible(int cur){ for(int i=1; i \u003c cur; i++){ //가로 세로 검사 if(col[i] == col[cur]) return false; //대각 검사 if(abs(cur - i) == abs(col[cur] - col[i])) return false; } return true; } void dfs(int row){ if(row \u003e n){ ans++; return; } for(int i=1; i\u003c=n; i++){ col[row] = i; if(possible(row)){ dfs(row + 1); } else{ col[row] = 0; } } } int main() { cin \u003e\u003e n; col.resize(n+1); for(int i=1; i\u003c=n; i++){ col[1] = i; //1,i부터 시작 dfs(2); } cout \u003c\u003c ans; } ","date":"2020-12-31","objectID":"/posts/2020-12-31-back_tracking/:2:1","tags":["Back Tracking","Theory"],"title":"백트래킹 (Back Tracking)","uri":"/posts/2020-12-31-back_tracking/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 9466번 - 텀 프로젝트 학생들은 프로젝트 팀을 구성하기 위해 프로젝트를 함께하고 싶은 1명의 학생을 선택해야한다. 자기자신을 선택하는 경우도 있다. (이 경우도 팀으로 간주) 학생들이$(s_1, s_2, …, s_r)$이라 할 때, r=1이고 $s_1$이 $s_1$을 선택하는 경우나, $s_1$이 $s_2$를 선택하고, $s_2$가 $s_3$를 선택하고,…, $s_{r-1}$이 $s_r$을 선택하고, $s_r$이 $s_1$을 선택하는 경우에만 한 팀이 될 수 있다. 학생들이 선택한 결과를 통해 팀으로 구성되지 않는 학생들의 수를 출력한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:1:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"Solution 문제에서 팀이 성립되는 경우는 선택한 학생들간에 사이클을 형성하는지 여부이다. 따라서 학생들이 선택한 결과를 통해 팀으로 구성되지 않는 학생들을 구하라는 말인즉슨 사이클을 형성하지 않는 학생들을 구하라는 말과도 동일하다. 문제에서 주어진 예시케이스를 가지고 방향 그래프를 구성하면 다음과 같아지며 학생들 중 $(3)$, $(4, 6, 7)$이 사이클을 형성하고 있음을 확인할 수 있다. 1 2 3 4 5 6 7 3 1 3 7 3 4 6 사이클을 판별하기 위해 DFS를 사용할 수도 있고, 위상정렬을 사용할 수도 있다. 본인은 문제를 해결하기위해 위상정렬을 사용하였다. 위상정렬은 사이클이 발생한 노드들에 대해서는 위상정렬을 수행할 수 없게되므로 DAG(Directed Acyclic Graph)에만 적용이 가능하다. 즉, 사이클이 발생하기 전까지는 위상정렬을 수행할 수 있다. 이 부분에 착안하여 본 문제에서는 요구하고 있는 사이클이 발생하지 않은 학생들의 수를 구하기위해 사이클이 발생하기 전까지 정렬이 수행되는 횟수를 카운트해주기로 했다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:2:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"수행단계 (위상정렬) 학생들이 선택한 결과를 통해 방향 그래프를 구성한다. 첫번째부터 마지막까지 순회하여 진입차수가 0인 학생들을 큐에 삽입한다. 사이클이 발생하지 않는 경우를 카운트한다. 큐의 front에 있는 노드와 연결된 다른 노드들의 진입차수를 1만큼 감소시킨다. 연결된 다른 노드 중 진입차수가 0인 노드를 큐에 삽입한다. 큐의 front에 있는 노드를 제거한다. 카운트 값을 증가시킨다. 큐가 empty일 때까지 반복한다. 주어진 예시케이스를 가지고 위의 단계들을 수행하면 3명의 학생들이 팀을 구성하지 못하는 것을 알 수 있다. 진입차수가 0인 2와 5를 큐에 삽입한다. (카운트는 2) 큐에서 2를 꺼내고 2와 연결된 1의 진입차수를 감소시킨다. 이 때, 1은 진입차수가 0이 되므로 큐에 삽입한다. (카운트는 3) 큐에서 5를 꺼내고 5와 연결된 3의 진입차수를 감소시킨다. 큐에서 1을 꺼내고 1이랑 연결된 3의 진입차수를 감소시킨다. 큐가 비었으므로 반복을 종료한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:2:1","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"Code ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:3:0","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"위상정렬을 사용한 코드 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; int main() { ios::sync_with_stdio(false); cin.tie(NULL); int tc; cin \u003e\u003e tc; while(tc-- \u003e 0){ int n, ans = 0; vector\u003cvector\u003cint\u003e\u003e graph; vector\u003cint\u003e indegree; queue\u003cint\u003e q; cin \u003e\u003e n; graph.resize(n+1); indegree.resize(n+1); //그래프 생성 for(int from=1; from\u003c=n; from++){ int to; cin \u003e\u003e to; graph[from].push_back(to); indegree[to]++; } //진입차수가 0인 그래프 탐색 for(int i=1; i\u003c=n; i++){ if(indegree[i] == 0) q.push(i); } while(!q.empty()){ int cur = q.front(); ans++; q.pop(); //진입차수 제거 for(int next : graph[cur]){ indegree[next] -= 1; //새롭게 진입차수가 0이 되는 노드 삽입 if(indegree[next] == 0){ q.push(next); } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } } ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_9466/:3:1","tags":["BOJ","Topology Sort"],"title":"[백준] 9466. 텀 프로젝트","uri":"/posts/2020-12-29-b_9466/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 17472번 - 다리 만들기 2 나라는 섬들로 이루어지고, 모든 섬을 다리로 연결하려고 한다. N×M 크기의 지도에서 1은 땅 0은 바다를 나타내며 섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말한다. 섬과 섬간의 다리는 직선인 경우(가로, 세로)에만 성립하며 다리의 길이가 2이상 되어야한다. 모든 섬을 연결하는 다리 길이의 최솟값을 출력하며 모든 섬을 연결하는 것이 불가능한 경우에는 -1을 출력하도록 한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:1:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"Solution MST를 구하는 문제이다. 다른 일반적인 MST 문제는 정점의 번호와 간선 및 비용이 친절하게 주어지나, 이 문제는 지도를 통해 정점, 간선 및 비용을 직접 구해야한다. BFS(또는 DFS)와 크루스칼을 조합하여 문제를 해결하는 방식이다보니 재미있게 풀었다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:2:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"수행단계 섬들을 만든다 BFS또는 DFS를 통해 섬들을 탐색한다. 각 섬들에 인덱스를 매긴다. 각 섬들을 잇는 모든 다리들을 구한다. 각 섬들을 구성하는 좌표마다 가로, 세로 탐색을 수행한다. 탐색 시 바다라면 카운트 값을 증가시킨다. 탐색 시 땅이라면 인덱스 값을 확인한다. 탐색이 시작된 땅의 인덱스값과 현재 도달한 땅의 인덱스 값이 다르면 카운트 값이 2이상인지 조회한다. 카운트 값이 2이상이라면 간선 리스트에 시작 인덱스, 종료 인덱스, 카운트 값을 하나의 간선 정보로 하여 포함시킨다. 최소신장트리를 구한다. 간선 리스트에 포함된 간선들의 비용을 기준으로하여 정렬한다. Union-find를 사용하여 MST를 구성하며 find가 수행될때마다 간선의 비용을 누적시키고 MST에 포함되는 노드 갯수를 1씩 증가시킨다. MST에 포함된 노드갯수와 섬들의 갯수 일치여부를 검사한다. 갯수가 일치하면 누적된 간선 비용 값을 출력한다. 갯수가 불일치시 -1을 출력한다. ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:2:1","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"Code 원본 배열(지도)에 정점의 인덱스 값을 할당해도 되겠지만, 본인은 unordered_map을 사용하여 해싱하는 방식으로 풀었다. 문제를 해결하는 것 외에도 본인만의 코딩컨벤션을 정립해서 읽기 쉬운 코드가 될 수 있도록 노력을 기울여야겠다. #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cunordered_map\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e #define LAND 1 #define LEN 11 #define MAX 7 using namespace std; int country[LEN][LEN]; bool visit[LEN][LEN]; int dx[] = {1, -1, 0, 0}; int dy[] = {0, 0, 1, -1}; unordered_map\u003cint, int\u003e vertex_index; int sz = 1; vector\u003cvector\u003cint\u003e\u003e edge; //from ,to, cost int root[MAX]; int depth[MAX]; //union by rank int hash_func(int y, int x){ return y*10 + x; } void get_vertex(int m, int n){ // y, x queue\u003cpair\u003cint,int\u003e\u003e q; for(int i=1; i\u003c=m; i++){ for(int j=1; j\u003c=n; j++){ if(country[i][j] == LAND \u0026\u0026 !visit[i][j]){ q.push({i,j}); //y,x visit[i][j] = true; while(!q.empty()){ pair\u003cint,int\u003e tmp = q.front(); for(int k=0; k\u003c4; k++){ int y = tmp.first + dy[k]; int x = tmp.second + dx[k]; if(1 \u003c= x \u0026\u0026 x \u003c= n \u0026\u0026 1 \u003c= y \u0026\u0026 y\u003c= m){ if(country[y][x] == LAND \u0026\u0026 !visit[y][x]){ q.push({y, x}); visit[y][x] = true; } } } q.pop(); vertex_index[hash_func(tmp.first,tmp.second)] = sz; } sz++; } } } sz--; } void find_edge(int y, int x, bool flag){ for(int i=1; i\u003c=y; i++){ int from = 0, to = 0, cost = 0; for(int j=1; j\u003c=x; j++){ int node = flag ? country[i][j] : country[j][i]; if(node == LAND){ int tmp = flag ? vertex_index[hash_func(i,j)] : vertex_index[hash_func(j,i)]; if(from == 0){ from = tmp; } else{ to = tmp; if(from != to){ //to를 만난 경우 if(cost \u003e= 2){ edge.push_back({from, to, cost}); } cost = 0; from = to; to = 0; } else cost = 0; } } else if(from != 0) cost++; } } } void get_edge(int m, int n){ find_edge(m, n, true); //horizontal find_edge(n, m, false); //vertical } bool cmp(vector\u003cint\u003e \u0026t, vector\u003cint\u003e \u0026u){ return t[2] \u003c u[2]; //cost 기준 } void init(int n){ for(int i=1; i\u003c=n; i++){ root[i] = i; depth[i] = 0; } } int find(int node){ if(root[node] == node){ return node; } else{ return root[node] = find(root[node]); } } bool do_union(int x, int y){ x = find(x); y = find(y); if(x==y) return false; if(depth[x] \u003c depth[y]){ root[x] = y; } else{ root[y] = x; if(depth[x] == depth[y]){ depth[x]++; } } return true; } int main() { int m, n, cnt = 0, answer = 0; cin \u003e\u003e m \u003e\u003e n; for(int i=1; i\u003c=m; i++){ for(int j=1; j\u003c=n; j++){ cin \u003e\u003e country[i][j]; } } get_vertex(m, n); get_edge(m, n); sort(edge.begin(), edge.end(), cmp); init(MAX - 1); for(vector\u003cint\u003e e : edge){ if(do_union(e[0], e[1])){ answer += e[2]; cnt++; } if(cnt == sz-1) break; } if(sz \u003c 2 || cnt != sz - 1) answer = -1; cout \u003c\u003c answer; } ","date":"2020-12-29","objectID":"/posts/2020-12-29-b_17472/:3:0","tags":["BOJ","Kruskal","DFS","BFS"],"title":"[백준] 17472. 다리 만들기 2","uri":"/posts/2020-12-29-b_17472/"},{"categories":["PS"],"content":"문제 설명 문제 : 백준 8972번 - 미친 아두이노 SWEA에 나올법한 구현 문제이다. 아래의 과정을 통해서 시뮬레이션한 결과를 출력하며, 미친 아두이노와 플레이어(종수)의 아두이노가 동일한 좌표에 위치하면 시뮬레이션을 종료시키고 “kraj X\"라는 문자열을 출력한다. (X는 시뮬레이션이 종료된 단계) 먼저, 종수가 아두이노를 8가지 방향(수직,수평,대각선)으로 이동시키거나, 그 위치에 그대로 놔둔다. 종수의 아두이노가 미친 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되며, 종수는 게임을 지게 된다. 미친 아두이노는 8가지 방향 중에서 종수의 아두이노와 가장 가까워 지는 방향으로 한 칸 이동한다. 즉, 종수의 위치를 $(r1,s1)$, 미친 아두이노의 위치를 $(r2, s2)$라고 했을 때, $|r1-r2| + |s1-s2|$가 가장 작아지는 방향으로 이동한다. 미친 아두이노가 종수의 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되고, 종수는 게임을 지게 된다. 2개 또는 그 이상의 미친 아두이노가 같은 칸에 있는 경우에는 큰 폭발이 일어나고, 그 칸에 있는 아두이노는 모두 파괴된다. ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:1:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"Solution 이 문제의 핵심은 2개또는 그 이상의 미친 아두이노 존재시 파괴라는 점이다. 이 부분을 염두에 두고 시뮬레이션 코드를 작성해야하는데 본인은 이를 간과하고 알고리즘을 설계했다가 낭패를 봤다. 문제를 풀다가 아두이노가 미쳐버리는게 아니라 내가 미쳐버릴뻔 했다.. ㅎㅎ 미친 아두이노가 이동하는 좌표에 다른 미친 아두이노가 존재할때 파괴를 시키면 다음과 같은 경우에서 올바른 결과를 보장하지 못한다. 이동 시 미친 아두이노가 존재하면 파괴 (잘못된 경우) $(3,3)$에서 $(3,2)$로 이동 $(2,2)$에서 $(3,2)$로 이동 따라서, 모든 미친 아두이노가 이동 후에 좌표가 겹치는지 여부를 검사한 후 겹친다면 폭팔을 수행해야한다. 올바른 경우 $(3,3)$에서 $(3,2)$로 이동 $(2,2)$에서 $(3,2)$로 이동 $(3,2)$에서 $(4,1)$로 이동 모든 아두이노 이동 후 겹치는좌표 폭팔 ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:2:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"수행단계 종수를 이동시킨다. 이동시키고자 하는 위치에 미친 아두이노가 존재하면 return '.' 이라면 종수의 위치 갱신 및 map 갱신(새로운 좌표에 ‘I’ 할당, 기존 좌표에 '.' 할당) 미친 아두이노를 이동시킨다. 8가지 방향 중 $| r1 - r2 | + | s1 - s2 |$가 최소인 방향을 설정한다. (범위를 벗어나는 좌표라면 continue) 이동시키고자 하는 위치에 종수가 존재하면 return 미친 아두이노의 위치만 갱신 미친 아두이노들이 이동한 좌표에서 충돌여부를 검사한다. 충돌이 발생한 미친 아두이노들은 리스트에서 제거 충돌이 발생하지 않은 미친 아두이노들의 위치 값을 통해 map 갱신(새로운 좌표에 ‘R’ 할당, 기존 좌표에 '.' 할당) 1번부터 재반복한다. ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:2:1","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"},{"categories":["PS"],"content":"Code 코드를 다 작성하고 제출하니 시간초과 판정을 받았다. ㅂㄷㅂㄷ… 기존 코드에서는 위 수행단계 3의 과정을위해 아래의 코드로 작성하였는데, 이 경우 각각의 미친 아두이노가 나머지 모든 미친 아두이노와 값을 비교하기 때문에 $O(N^2)$이 소요된다. //R와 충돌 검사 및 폭팔 처리 for(int i=0; i \u003c crazy.size(); i++){ if(check[i]) continue; bool bomb = false; int ty = crazy[i].first; int tx = crazy[i].second; for(int j=0; j \u003c crazy.size(); j++){ if(i == j) continue; int uy = crazy[j].first; int ux = crazy[j].second; if(ty == uy \u0026\u0026 tx == ux){ check[j] = true; bomb = true; } } if(!bomb) map[ty][tx] = CRAZY; else check[i] = true; } 시복잡도를 최소화 시키기 위해 미친 아두이노들의 좌표값들을 정렬해준 후 순회하며 아래의 단계를 수행하는 것으로 변경하였다. crazy[i]의 충돌여부 검사시 j는 i 인덱스로 설정 crazy[i]와 crazy[j+1]이 같지 않을때까지 j인덱스 증가 i의 인덱스와 j의 인덱스가 같다면 crazy[i]는 충돌이 일어나지 않았으므로 map 갱신 및 새로운 리스트에 삽입 i와 j의 인덱스가 다르다면 i ~ j-1까지는 충돌이 발생. 다음 비교를 위해서 i는 j 인덱스로 변경 따라서 시복잡도는 $O(NlogN)$이 되게된다. //R와 충돌 검사 및 폭팔 처리 sort(crazy.begin(), crazy.end()); vector\u003cpair\u003cint,int\u003e\u003e temp; for(int i=0; i \u003c crazy.size(); i++){ int j = i; //충돌이 발생하는 인덱스는 건너뛰기 while(j \u003c crazy.size() \u0026\u0026 crazy[i] == crazy[j+1]){ j++; } if(i==j){ // 충돌이 발생하지 않은 경우 int cy = crazy[i].first; int cx = crazy[i].second; map[cy][cx] = CRAZY; temp.push_back(crazy[i]); } else i = j; // 인덱스 변경 (건너뛰기) } crazy = temp; 전체 코드는 아래와 같다. #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e#define LEN 101 #define CRAZY 'R' #define PLAYER 'I' #define EMPTY '.' #define INF 1e9 using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(NULL); int R, C, step = 0; vector\u003cstring\u003e map; pair\u003cint,int\u003e player; vector\u003cpair\u003cint,int\u003e\u003e crazy; string command; bool is_end = false; int dx[] = {0,-1,0,1,-1,0,1,-1,0,1}; // 1 ~ 9, 0은 dummy int dy[] = {0,1,1,1,0,0,0,-1,-1,-1}; // 입력 cin \u003e\u003e R \u003e\u003e C; for(int i=0; i\u003cR; i++){ string row; cin \u003e\u003e row; map.push_back(row); for(int j=0; j\u003cC; j++){ if(map[i][j] == CRAZY) crazy.push_back({i, j}); // y,x if(map[i][j] == PLAYER) player = {i, j}; } } cin \u003e\u003e command; for(char c : command){ int cmd = c - '0'; // 플레이어 이동 int py = player.first + dy[cmd]; int px = player.second + dx[cmd]; step++; is_end = map[py][px] == CRAZY; //R과 충돌 검사 if(is_end) break; map[player.first][player.second] = EMPTY; map[py][px] = PLAYER; player = {py, px}; //미친 아두이노 이동 for(int i=0; i \u003c crazy.size(); i++){ int cy, cx, judge = INF; for(int k=1; k\u003c=9; k++){ if(k==5) continue; int ty = crazy[i].first + dy[k]; int tx = crazy[i].second + dx[k]; if(0 \u003e ty || ty \u003e= R || 0 \u003e tx || tx \u003e= C) continue; int val = abs(py - ty) + abs(px - tx); if(judge \u003e val){ judge = val; cy = ty; cx = tx; } } is_end = map[cy][cx] == PLAYER; // I와 충돌 검사 if(is_end) goto escape; map[crazy[i].first][crazy[i].second] = EMPTY; crazy[i] = {cy, cx}; } //R와 충돌 검사 및 폭팔 처리 sort(crazy.begin(), crazy.end()); vector\u003cpair\u003cint,int\u003e\u003e temp; for(int i=0; i \u003c crazy.size(); i++){ int j = i; //충돌이 발생하는 인덱스는 건너뛰기 while(j \u003c crazy.size() \u0026\u0026 crazy[i] == crazy[j+1]){ j++; } if(i==j){ // 충돌이 발생하지 않은 경우 int cy = crazy[i].first; int cx = crazy[i].second; map[cy][cx] = CRAZY; temp.push_back(crazy[i]); } else i = j; // 인덱스 변경 (건너뛰기) } crazy = temp; } escape:; if(is_end){ cout \u003c\u003c \"kraj \" \u003c\u003c step; } else{ for(int i=0; i\u003cR; i++){ cout \u003c\u003c map[i] \u003c\u003c '\\n'; } } } ","date":"2020-12-28","objectID":"/posts/2020-12-28-b_8972/:3:0","tags":["BOJ","구현"],"title":"[백준] 8972. 미친 아두이노","uri":"/posts/2020-12-28-b_8972/"}]